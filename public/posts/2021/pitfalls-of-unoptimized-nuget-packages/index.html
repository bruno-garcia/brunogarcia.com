<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pitfalls of Unoptimized NuGet Packages | Bruno Garcia</title><meta name=keywords content=".NET,Assembly,NuGet,Optimization"><meta name=description content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="Pitfalls of Unoptimized NuGet Packages"><meta property="og:description" content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-21T16:20:00-04:00"><meta property="article:modified_time" content="2021-05-21T16:20:00-04:00"><meta property="article:tag" content=".NET"><meta property="article:tag" content="Assembly"><meta property="article:tag" content="NuGet"><meta property="article:tag" content="Optimization"><meta property="og:image" content="http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover.jpg"><meta name=twitter:title content="Pitfalls of Unoptimized NuGet Packages"><meta name=twitter:description content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"Pitfalls of Unoptimized NuGet Packages","item":"http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pitfalls of Unoptimized NuGet Packages","name":"Pitfalls of Unoptimized NuGet Packages","description":"Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector.","keywords":[".NET","Assembly","NuGet","Optimization"],"articleBody":"Summary You might unknowingly be using an unoptimized dependency which could impact the performance of your app. Now, it’s easy to get a warning if that happens, at build time, using the NuGet package UnoptimizedAssemblyDetector:\n","wordCount":"2134","inLanguage":"en","image":"http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover.jpg","datePublished":"2021-05-21T16:20:00-04:00","dateModified":"2021-05-21T16:20:00-04:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Pitfalls of Unoptimized NuGet Packages</h1><div class=post-description>Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector.</div></header><figure class=entry-cover><img loading=eager srcset='http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover_hu_cbb2cf68605f1791.jpg 360w,http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover_hu_694278fbf7d9acb0.jpg 480w,http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover_hu_61bf01a4389f9051.jpg 720w,http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover_hu_54e40ee0d421c355.jpg 1080w,http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover_hu_9953e93436147c24.jpg 1500w,http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover.jpg 4929w' src=http://localhost:8322/posts/2021/pitfalls-of-unoptimized-nuget-packages/snail-cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=4929 height=3418 alt="A Snail."></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#whats-the-pitfall aria-label="What&rsquo;s the pitfall?">What&rsquo;s the pitfall?</a></li><li><a href=#why-should-i-care aria-label="Why should I care?">Why should I care?</a><ul><li><a href=#benchmarks aria-label=Benchmarks>Benchmarks</a><ul><li><a href=#debug-run aria-label="Debug run">Debug run</a></li><li><a href=#release-run aria-label="Release run">Release run</a></li></ul></li><li><a href=#optimizations aria-label=Optimizations>Optimizations</a></li></ul></li><li><a href=#sensible-defaults aria-label="Sensible defaults">Sensible defaults</a><ul><li><a href=#release-as-default aria-label="Release as default">Release as default</a></li></ul></li><li><a href=#debug-builds-on-nugetorg aria-label="Debug builds on nuget.org">Debug builds on nuget.org</a></li><li><a href=#my-days-are-numbered aria-label="My days are numbered">My days are numbered</a></li></ul></div></details></div><div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>You might unknowingly be using an unoptimized dependency which could impact the performance of your app.
Now, it&rsquo;s easy to get a warning if that happens, at build time,
using the NuGet package <a href=https://www.nuget.org/packages/UnoptimizedAssemblyDetector/><code>UnoptimizedAssemblyDetector</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#ff79c6>&lt;PackageReference</span> <span style=color:#50fa7b>Include=</span><span style=color:#f1fa8c>&#34;UnoptimizedAssemblyDetector&#34;</span> <span style=color:#50fa7b>Version=</span><span style=color:#f1fa8c>&#34;0.1.0&#34;</span><span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;PrivateAssets&gt;</span>all<span style=color:#ff79c6>&lt;/PrivateAssets&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>&lt;/PackageReference&gt;</span>
</span></span></code></pre></div><p>After you add this NuGet package, a warning will be included in your build if any unoptimized assembly is detected.</p><p><a href=/posts/2021/pitfalls-of-unoptimized-nuget-packages/unoptimized-assembly-detected.gif><img alt=unoptimized-assembly-detected loading=lazy src=/posts/2021/pitfalls-of-unoptimized-nuget-packages/unoptimized-assembly-detected.gif></a></p><p>The source code of project is <a href=https://github.com/bruno-garcia/unoptimized-assembly-detector>hosted on GitHub</a> ⭐.</p><h2 id=whats-the-pitfall>What&rsquo;s the pitfall?<a hidden class=anchor aria-hidden=true href=#whats-the-pitfall>#</a></h2><p>The default build configuration for <code>dotnet pack</code> and <code>dotnet publish</code> is not <code>Release</code> as you might assume or expect.
When publishing NuGet packages to <em>nuget.org</em>, one must explicitly make it a release package, like: <code>dotnet pack -c Release</code>. Without it, the assemblies packed will not be compiled with optimizations.
In this blog post you&rsquo;ll learn that&rsquo;s not always the case. Even for those who know, accidents happens and a misconfigured build script can result in a <code>Debug</code> build ending up on <em>nuget.org</em>.</p><p>The default value being <code>Debug</code>, which results in unoptimized assemblies, isn&rsquo;t alone the reason why this is a pitfall.
There&rsquo;s no warning of any kind from the point you create the NuGet package, through uploading to <em>nuget.org</em> all the way to restoring it for your project.</p><h2 id=why-should-i-care>Why should I care?<a hidden class=anchor aria-hidden=true href=#why-should-i-care>#</a></h2><p>If you don&rsquo;t need convincing, feel free to skip ahead to <a href=/posts/2021/pitfalls-of-unoptimized-nuget-packages/#sensible-defaults>Sensible defaults</a>.</p><h3 id=benchmarks>Benchmarks<a hidden class=anchor aria-hidden=true href=#benchmarks>#</a></h3><p>No pitfalls when running <code>BenchmarkDotNet</code> in debug mode. It stops you quickly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>➜ dotnet run
</span></span><span style=display:flex><span>// Validating benchmarks:
</span></span><span style=display:flex><span>Assembly UnoptimizedBenchmarks which defines benchmarks is non-optimized
</span></span><span style=display:flex><span>Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE.
</span></span><span style=display:flex><span>If you want to debug the benchmarks, please see https://benchmarkdotnet.org/articles/guides/troubleshooting.html#debugging-benchmarks.
</span></span></code></pre></div><p>We can force it by using <code>DebugBuildConfig</code> and to illustrate some of the differences between <code>Release</code> and <code>Debug</code> builds,
I adapted a Fibonacci benchmark <a href=https://dev.to/newday-technology/measuring-performance-using-benchmarkdotnet-part-1-39g3>from this blog post</a> to compare the two:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>using System<span style=color:#ff79c6>.</span>Collections<span style=color:#ff79c6>.</span>Generic;
</span></span><span style=display:flex><span>using System<span style=color:#ff79c6>.</span>Linq;
</span></span><span style=display:flex><span>using BenchmarkDotNet<span style=color:#ff79c6>.</span>Attributes;
</span></span><span style=display:flex><span>using BenchmarkDotNet<span style=color:#ff79c6>.</span>Running;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>var</span> summary <span style=color:#ff79c6>=</span> BenchmarkRunner<span style=color:#ff79c6>.</span>Run(<span style=color:#8be9fd;font-style:italic>typeof</span>(FibonacciBenchmark)<span style=color:#ff79c6>.</span>Assembly 
</span></span><span style=display:flex><span><span style=color:#6272a4>#if DEBUG</span>
</span></span><span style=display:flex><span>    ,new BenchmarkDotNet<span style=color:#ff79c6>.</span>Configs<span style=color:#ff79c6>.</span>DebugBuildConfig()
</span></span><span style=display:flex><span><span style=color:#6272a4>#endif</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>public <span style=color:#ff79c6>class</span> FibonacciBenchmark
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    [Params(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>13</span>, <span style=color:#bd93f9>21</span>, <span style=color:#bd93f9>34</span>)]
</span></span><span style=display:flex><span>    public int Count { get; set; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [Benchmark]
</span></span><span style=display:flex><span>    public void Fibonacci() <span style=color:#ff79c6>=&gt;</span> _ <span style=color:#ff79c6>=</span> GetFibonacci(Count)<span style=color:#ff79c6>.</span>ToList();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    IEnumerable<span style=color:#ff79c6>&lt;</span>int<span style=color:#ff79c6>&gt;</span> GetFibonacci(int count)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>var</span> w <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>; <span style=color:#ff79c6>var</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>yield</span> <span style=color:#ff79c6>return</span> x;
</span></span><span style=display:flex><span>        foreach (<span style=color:#ff79c6>var</span> _ <span style=color:#ff79c6>in</span> Enumerable<span style=color:#ff79c6>.</span>Range(<span style=color:#bd93f9>1</span>, count <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>var</span> y <span style=color:#ff79c6>=</span> w <span style=color:#ff79c6>+</span> x;
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>yield</span> <span style=color:#ff79c6>return</span> y;
</span></span><span style=display:flex><span>            w <span style=color:#ff79c6>=</span> x;
</span></span><span style=display:flex><span>            x <span style=color:#ff79c6>=</span> y;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=debug-run>Debug run<a hidden class=anchor aria-hidden=true href=#debug-run>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>➜ dotnet run -c Debug
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BenchmarkDotNet=v0.13.0, OS=macOS Big Sur 11.2.3 (20D91) [Darwin 20.3.0]
</span></span><span style=display:flex><span>Intel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores
</span></span><span style=display:flex><span>.NET SDK=6.0.100-preview.3.21202.5
</span></span><span style=display:flex><span>  [Host]     : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT
</span></span><span style=display:flex><span>  DefaultJob : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BuildConfiguration=Debug  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>|    Method | Count |      Mean |    Error |   StdDev |
</span></span><span style=display:flex><span>|---------- |------ |----------:|---------:|---------:|
</span></span><span style=display:flex><span>| Fibonacci |     1 |  83.99 ns | 1.271 ns | 0.992 ns |
</span></span><span style=display:flex><span>| Fibonacci |     2 | 109.46 ns | 1.460 ns | 1.366 ns |
</span></span><span style=display:flex><span>| Fibonacci |     3 | 124.59 ns | 0.903 ns | 0.845 ns |
</span></span><span style=display:flex><span>| Fibonacci |     5 | 172.64 ns | 0.930 ns | 0.726 ns |
</span></span><span style=display:flex><span>| Fibonacci |     8 | 213.29 ns | 1.019 ns | 0.851 ns |
</span></span><span style=display:flex><span>| Fibonacci |    13 | 315.48 ns | 2.518 ns | 2.103 ns |
</span></span><span style=display:flex><span>| Fibonacci |    21 | 470.91 ns | 2.907 ns | 2.719 ns |
</span></span><span style=display:flex><span>| Fibonacci |    34 | 687.77 ns | 7.792 ns | 6.507 ns |
</span></span></code></pre></div><h4 id=release-run>Release run<a hidden class=anchor aria-hidden=true href=#release-run>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>➜ dotnet run -c Release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>|    Method | Count |      Mean |    Error |   StdDev |
</span></span><span style=display:flex><span>|---------- |------ |----------:|---------:|---------:|
</span></span><span style=display:flex><span>| Fibonacci |     1 |  60.52 ns | 0.436 ns | 0.364 ns |
</span></span><span style=display:flex><span>| Fibonacci |     2 |  81.21 ns | 0.465 ns | 0.388 ns |
</span></span><span style=display:flex><span>| Fibonacci |     3 |  93.38 ns | 0.575 ns | 0.449 ns |
</span></span><span style=display:flex><span>| Fibonacci |     5 | 133.85 ns | 0.969 ns | 0.809 ns |
</span></span><span style=display:flex><span>| Fibonacci |     8 | 167.17 ns | 2.574 ns | 3.161 ns |
</span></span><span style=display:flex><span>| Fibonacci |    13 | 242.88 ns | 1.877 ns | 1.567 ns |
</span></span><span style=display:flex><span>| Fibonacci |    21 | 369.98 ns | 5.940 ns | 5.556 ns |
</span></span><span style=display:flex><span>| Fibonacci |    34 | 572.87 ns | 8.560 ns | 8.007 ns |
</span></span></code></pre></div><p>It&rsquo;s clear that compiling in <code>Release</code> mode significantly affects the performance of this benchmark.
How much that affects your app? You&rsquo;d need to measure it. It&rsquo;s possible that for your app it doesn&rsquo;t result in any noticeable slow downs. But it possibly can.</p><h3 id=optimizations>Optimizations<a hidden class=anchor aria-hidden=true href=#optimizations>#</a></h3><blockquote><p>Never use the Debug build for benchmarking. Never. The debug version of the target method can run 10–100 times slower.</p></blockquote><p>This came from <a href=https://benchmarkdotnet.org/articles/guides/good-practices.html>BenchmarkDotNet&rsquo;s Good Practices</a> documentation. The impact that it causes to your application might not be as severe or noticeable. Ironically, benchmarking is one of the tools to measure that.</p><p>The <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation#optimize>C# compiler docs</a> state:</p><blockquote><p>The Optimize option enables or disables optimizations performed by the compiler to make your output file smaller, faster, and more efficient. The Optimize option is enabled by default for a Release build configuration. It is off by default for a Debug build configuration.</p></blockquote><p>To go more in depth into what kinds of optimizations are done, lets refer to Eric Lippert, former Principal Engineer in the C# language design team and his blog post on the subject. <a href=https://web.archive.org/web/20110802071721/http://blogs.msdn.com/b/ericlippert/archive/2009/06/11/what-does-the-optimize-switch-do.aspx>Which we can read thanks to web.archive.org</a>:</p><ul><li>Expressions which are determined to be only useful for their side effects are turned into code that merely produces the side effects.</li><li>We omit generating code for things like <code>int foo = 0;</code> because we know that the memory allocator will initialize fields to default values.</li><li>We omit emitting and generating empty static class constructors. (Which typically happens if the static constructor set all the fields to their default value and the previous optimization eliminated all of them.)</li><li>We omit emitting a field for any hoisted locals that are unused in an iterator block. (This includes that case where the local in question is used only inside an anonymous function in the iterator block, in which case it is going to become hoisted into a field of the closure class for the anonymous function. No need to hoist it twice if we don’t need to.)</li><li>We attempt to minimize the number of local variable and temporary slots allocated. For example, if you have:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>for (int i = …) {…}
</span></span><span style=display:flex><span>for (int i = …) {…}
</span></span></code></pre></div><p>then the compiler could generate code to re-use the local variable storage reserved for <code>i</code> when the second <code>i</code> comes along. (We eschew this optimization if the locals have different names because then it gets hard to emit sensible debug info, which we still want to do even for the optimized build. However, the jitter is free to perform this optimization if it wishes to.)</p><ul><li>Also, if you have a local which is never used at all, then there is no storage allocated for it if the flag is set.</li><li>Similarly, the compiler is more aggressive about re-using the unnamed temporary slots sometimes used to store results of subexpression calculations.</li><li>Also, with the flag set the compiler is more aggressive about generating code that throws away “temporary” values quickly for things like controlling variables of switch statements, the condition in an “if” statement, the value being returned, and so on. In the non-optimized build these values are treated as unnamed local variables, loaded from and stored to specific locations. In the optimized build they can often be just kept on the stack proper.</li><li>We eliminate pretty much all of the “breakpoint convenience” no-ops.</li><li>If a try block is empty then clearly the catch blocks are not reachable and can be trimmed. (Finally blocks of empty tries are preserved as protected regions because they have unusual behaviour when faced with certain exceptions; see the comments for details.)</li><li>If we have an instruction which branches to <code>LABEL1</code>, and the instruction at <code>LABEL1</code> branches to <code>LABEL2</code>, then we rewrite the first instruction as a branch straight to <code>LABEL2</code>. Same with branches that go to returns.</li><li>We look for “branch over a branch” situations. For example, here we go to <code>LABEL1</code> if condition is false, otherwise we go to <code>LABEL2</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>brfalse condition, LABEL1
</span></span><span style=display:flex><span>br LABEL2
</span></span><span style=display:flex><span>LABEL1: somecode
</span></span></code></pre></div><p>Since we are simply branching over another branch, we can rewrite this as simply &ldquo;if condition is true, go to <code>LABEL2</code>&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>brtrue condition, LABEL2
</span></span><span style=display:flex><span>somecode
</span></span></code></pre></div><ul><li>We look for “branch to nop” situations. If a branch goes to a nop then you can make it branch to the instruction after the nop.</li><li>We look for “branch to next” situations; if a branch goes to the next instruction then you can eliminate it.</li><li>We look for two return instructions in a row; this happens sometimes and obviously we can turn it into a single return instruction.</li></ul><p>This text was written a long time ago. And since this writing, Eric Lippert left Microsoft and the C# compiler was rewritten and open sourced.
You can browse <a href=http://github.com/dotnet/roslyn>Roslyn&rsquo;s</a> repository and you&rsquo;ll <a href="https://github.com/dotnet/roslyn/issues?q=is%3Aissue+is%3Aopen+optimization+proposal">discover that new optimizations are still being suggested</a> and added.</p><h2 id=sensible-defaults>Sensible defaults<a hidden class=anchor aria-hidden=true href=#sensible-defaults>#</a></h2><p>I&rsquo;ve been talking about packaging NuGet with <code>Release</code> configuration then talking about Roslyn optimization.
These two things are not exactly the same (though by default related) and I wish to clarify.</p><p>The <code>Release</code> configuration, by default does provide the <code>-optimize+</code> flag to the C# compiler
but you can achieve the same for example by means of a MSBuild property <code>&lt;Optimize>true&lt;/Optimize></code>.
I hope the quote from the docs I include help make this clear.</p><blockquote><p>Optimize also tells the common language runtime to optimize code at runtime. By default, optimizations are disabled. Specify Optimize+ to enable optimizations. When building a module to be used by an assembly, use the same Optimize settings as used by the assembly. It&rsquo;s possible to combine the Optimize and Debug options.</p></blockquote><p><a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation#optimize>This passage from the C# compiler docs</a> isn&rsquo;t something new, and there has been a lot of debate about whether the default should be changed to <code>Release</code>.</p><h3 id=release-as-default>Release as default<a hidden class=anchor aria-hidden=true href=#release-as-default>#</a></h3><p><a href=https://github.com/aspnet/dnx/pull/3204><img alt="dnx issue release build for pack command" loading=lazy src=/posts/2021/pitfalls-of-unoptimized-nuget-packages/dnx-release-build-pack-dark.png></a></p><p>To me, it sounded pretty obvious at first that this should the right thing to do. As it did for a lot of folks on that thread.
But it turns out the .NET team has strong and valid opinions to why that shouldn&rsquo;t be the case.</p><p><a href=https://github.com/aspnet/dnx/pull/3204#issuecomment-159985967><img alt=davidfowl-nuget-package-debug loading=lazy src=/posts/2021/pitfalls-of-unoptimized-nuget-packages/davidfowl-nuget-package-debug-dark.png></a></p><h2 id=debug-builds-on-nugetorg>Debug builds on nuget.org<a hidden class=anchor aria-hidden=true href=#debug-builds-on-nugetorg>#</a></h2><p>Regardless of which side of the debate you stand, the truth of the matter is that we&rsquo;re left with packages being published to <em>nuget.org</em> with assemblies compiled without optimization.</p><br><div align=center><blockquote class=twitter-tweet><p lang=en dir=ltr>StructureMap 4.4.1 is up. No code changes, but corrects the problem of the nuget being built as Debug for 4.3.0 and 4.4.0. Oops on my part.</p>&mdash; jeremydmiller (@jeremydmiller) <a href="https://twitter.com/jeremydmiller/status/777571510919630848?ref_src=twsrc%5Etfw">September 18, 2016</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><blockquote class=twitter-tweet><p lang=en dir=ltr>I knew this would happen. I've done it myself and you won't be the last. More debug builds on NuGet ahead. <a href="https://twitter.com/davidfowl?ref_src=twsrc%5Etfw">@davidfowl</a></p>&mdash; Kristian Hellang (@khellang) <a href="https://twitter.com/khellang/status/777753550491353088?ref_src=twsrc%5Etfw">September 19, 2016</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></div><br><p>I feel like publishing packages to <em>nuget.org</em> relates a lot to sailing and running aground:</p><blockquote><p>There are three kinds of skippers, those who have run aground, those who will run aground, and those that have but won&rsquo;t admit it.</p></blockquote><p>Replace <em>skippers</em> with <em>package authors</em> and <em>running aground</em> with <em>publish packages built in debug</em> and there you have it.</p><p>Publishing unoptimized bits also happened to Sentry&rsquo;s <em>SharpRaven</em> SDK back in 2018. If you&rsquo;re using <a href=https://www.nuget.org/packages/SharpRaven/2.3.0>SharpRaven version 2.3.0</a>, you&rsquo;re running an unoptimized assembly. I would recommend you <a href=https://github.com/getsentry/raven-csharp/pull/226/files>upgrade it to 2.3.1</a> but on that same year that package was replaced by <a href=https://www.nuget.org/packages/Sentry/>Sentry</a>. Don&rsquo;t worry, it&rsquo;s <a href=https://github.com/getsentry/sentry-dotnet/blob/bc4c5e23eaaaa848a9a44ae05ac257a591624b24/build.ps1#L14>packaged in release mode</a>. Not that you should take my word for it.</p><p>In early 2020, I even <a href=https://github.com/getsentry/sentry-dotnet/pull/365/files>opened a PR to add this verification to the Sentry SDK for .NET</a> so it would check assemblies being loaded whether they were optimized or not, and send events to Sentry when applicable. But it never felt like the right thing to do. This verification must happen much earlier, at latest during build time. For this reason <a href=https://www.nuget.org/packages/UnoptimizedAssemblyDetector/><code>UnoptimizedAssemblyDetector</code></a> was born.</p><h2 id=my-days-are-numbered>My days are numbered<a hidden class=anchor aria-hidden=true href=#my-days-are-numbered>#</a></h2><p>That&rsquo;s a gloomy heading. It&rsquo;s the <code>UnoptimizedAssemblyDetector</code> NuGet package talking though, not me.
I built this package in hopes for it to become obsolete one day. Not because I expect the default of <code>dotnet pack</code> to ever change.
Clearly it won&rsquo;t. But I believe such warnings should be part of NuGet itself.</p><p>When you push a NuGet package to <em>nuget.org</em>, it should verify if the managed assemblies under <code>lib/</code> are indeed compiled with optimization, and if not, it should warn the author.
At the same time, when restoring such package, it should warn the consumer. This part in particular will make <code>UnoptimizedAssemblyDetector</code> redundant.</p><p>What else can <strong>we</strong> do? <a href=https://github.com/dotnet/nuget-trends>NuGet Trends</a> has the complete catalog. It could be extended to download the packages and inspect the assemblies in them. With that, create graphs and expose an endpoint to list unoptimized assemblies.</p><p>Well that, and ask the NuGet team to add these checks during package upload/restore.</p><p>&ndash;
Cover photo by <a href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">amirali mirhashemian</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/.net/>.NET</a></li><li><a href=http://localhost:8322/tags/assembly/>Assembly</a></li><li><a href=http://localhost:8322/tags/nuget/>NuGet</a></li><li><a href=http://localhost:8322/tags/optimization/>Optimization</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>