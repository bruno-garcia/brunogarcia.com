<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wake on Lan in C# and Windows 8 | Bruno Garcia</title><meta name=keywords content="C#,Network"><meta name=description content="Sending Wake-on-LAN magic packets in C# to remotely power on machines over the network, with Windows 8 considerations."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="Wake on Lan in C# and Windows 8"><meta property="og:description" content="Sending Wake-on-LAN magic packets in C# to remotely power on machines over the network, with Windows 8 considerations."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-04-21T20:24:00+02:00"><meta property="article:modified_time" content="2013-04-21T20:24:00+02:00"><meta property="article:tag" content="C#"><meta property="article:tag" content="Network"><meta property="og:image" content="http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/Wake-on-Lan-on-Wireshark.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/Wake-on-Lan-on-Wireshark.png"><meta name=twitter:title content="Wake on Lan in C# and Windows 8"><meta name=twitter:description content="Sending Wake-on-LAN magic packets in C# to remotely power on machines over the network, with Windows 8 considerations."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"Wake on Lan in C# and Windows 8","item":"http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wake on Lan in C# and Windows 8","name":"Wake on Lan in C# and Windows 8","description":"Sending Wake-on-LAN magic packets in C# to remotely power on machines over the network, with Windows 8 considerations.","keywords":["C#","Network"],"articleBody":"About 8 years ago I was writing scripts to run on a network with over 130.000 computers (of which 5000 I administered). The scripts ran 24/7, parsing computer’s inventory log files, which they sent to a central server. It was possible to detect and fix a whole bunch of issues, most of the time even before a user would notice something was wrong.\nNote that most of those computers were running Windows NT 4, including the domain controllers. The task to install application in all those computers and keep their anti-virus signature up-to-date was not as trivial as it is today. There were times we needed to perform tasks on computers that weren’t even switched on. And I must admit, back then I was quite proud of the solution I came up with for this particular case. Although it’s not my goal to go into details on how I managed to get any of those 5000 computers, spread in 130 different offices, powered-on at any time; I want to write a little about the core of the solution: Wake on Lan\nWhether to be able to power on your computer at home when you are away, or to manage a corporate network, the ability to switch a computer on out of sending a magic packet is at least quite interesting. It does require basic knowledge of computer networks and hardware to understand it, but to make it work, all you need is to know how to find your computer’s MAC address. That’s all you need to use WoL on a local network. However if you are willing to use it over the Internet, you’ll need the IP address of the gateway of which the target computer belongs to, and have that gateway configured to forward the magic packet to the private network. The Port number is used in this case (if you use NAT, you’ll need it), so that you can forward incoming UDP datagram on that predefined port of your router to an internal network IP address, or even the broadcast address if you’d like.\nIf the computer is switched off, it’s likely the network switch’s CAM table won’t have an entry to your target computer’s MAC address, and once your router forwards the datagram received from the external interface to your internal network, to the specific IP address you defined on the forwarding rule, the network switch will broadcast that to all ports.\nYou’ll find many over-architected implementations of Wake on Lan out there, even in C#. But the fact is that it’s really simple thing.\nLet’s see some C# code: using System; using System.Net; using System.Net.NetworkInformation; using System.Net.Sockets; using System.Text.RegularExpressions; namespace BrunoGarcia.Net { public sealed class WolManager { const int _payloadSize = 102; public static void SendMagicPacket(string mac, IPEndPoint ipEndPoint) { var macBytes = PhysicalAddress.Parse(mac).GetAddressBytes(); var payload = new byte[_payloadSize]; Buffer.BlockCopy(new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }, 0, payload, 0, 6); for (int i = 1; i \u003c 17; i++) Buffer.BlockCopy(macBytes, 0, payload, 6 * i, 6); using (var udp = new UdpClient()) udp.Send(payload, _payloadSize, ipEndPoint); } } } As you can see, it’s a fire-and-forget operation, a single UDP datagram. The MAC address of the target machine goes in the payload. As I mentioned before, the port is not really important if you are sending the packet on the same subnet of your target computer (without the need of routing). Port on wikipedia you find to be 7 or 9. However 0 can be used:\nWolManager.SendMagicPacket(\"B8-AC-6F-59-56-55\", new IPEndPoint(IPAddress.Parse(\"255.255.255.255\"), 0)); This is fun, and I’ve used it to power on my computer at home from the Internet a few times. But now, when I got Windows 8, the fun wasn’t quite working.\nThis KB from Microsoft describes the change:\nWindows 7: In Windows 7, the default shutdown operation puts the system into classic shutdown (S5) and all devices are put into the lowest power state D3. Wake-On-LAN is not officially supported from S5 in Windows 7. However, some network adapters can be left armed for wake if enough residual power is available. As a result, wake from the S5 state is possible on some systems where enough residual power was supplied to the network adapter even though the system is in S5 and devices are in D3.\nWindows 8: In Windows 8, the default shutdown behavior puts the system into hybrid shutdown (S4) and all devices are put into D3. Remote Wake-On-LAN from hybrid shutdown (S4) or classic shutdown (S5) is unsupported. Network adapters are explicitly not armed for Wake-On-LAN in both the classic shutdown (S5) and hybrid shutdown (S4) cases because users expect zero power consumption and battery drain in the shutdown state. This behavior removes the possibility of spurious wakes when explicit shutdown was requested. As a result, Wake-On-LAN is only supported from sleep (S3) or hibernate (S4) in Windows 8.\nWhat a bummer. Anyway, not time to give up, right? Digging a bit deeper one understands better the changes, and enabling wake on lan on windows 8 is possible again:\nCheck out this post from Phil Pendlebury which talks about it.\n","wordCount":"850","inLanguage":"en","image":"http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/Wake-on-Lan-on-Wireshark.png","datePublished":"2013-04-21T20:24:00+02:00","dateModified":"2013-04-21T20:24:00+02:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2013/wake-on-lan-in-c-and-windows-8/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Wake on Lan in C# and Windows 8</h1><div class=post-description>Sending Wake-on-LAN magic packets in C# to remotely power on machines over the network, with Windows 8 considerations.</div><div class=post-meta><span title='2013-04-21 20:24:00 +0200 +0200'>April 21, 2013</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Bruno Garcia</span></div></header><div class=post-content><p>About 8 years ago I was writing scripts to run on a network with over 130.000 computers (of which 5000 I administered).
The scripts ran 24/7, parsing computer&rsquo;s inventory log files, which they sent to a central server. It was possible to detect and fix a whole bunch of issues, most of the time even before a user would notice something was wrong.</p><p>Note that most of those computers were running Windows NT 4, including the domain controllers. The task to install application in all those computers and keep their anti-virus signature up-to-date was not as trivial as it is today. There were times we needed to perform tasks on computers that weren&rsquo;t even switched on. And I must admit, back then I was quite proud of the solution I came up with for this particular case. Although it&rsquo;s not my goal to go into details on how I managed to get any of those 5000 computers, spread in 130 different offices, powered-on at any time; I want to write a little about the core of the solution: <strong>Wake on Lan</strong></p><p>Whether to be able to power on your computer at home when you are away, or to manage a corporate network, the ability to switch a computer on out of sending a <em>magic packet</em> is at least quite interesting. It does require basic knowledge of computer networks and hardware to understand it, but to make it work, all you need is to know how to find your computer&rsquo;s MAC address. That&rsquo;s all you need to use WoL on a local network. However if you are willing to use it over the Internet, you&rsquo;ll need the IP address of the gateway of which the target computer belongs to, and have that gateway configured to forward the <em>magic packet</em> to the private network. The Port number is used in this case (if you use NAT, you&rsquo;ll need it), so that you can forward incoming UDP datagram on that predefined port of your router to an internal network IP address, or even the broadcast address if you&rsquo;d like.</p><p>If the computer is switched off, it&rsquo;s likely the network switch&rsquo;s CAM table won&rsquo;t have an entry to your target computer&rsquo;s MAC address, and once your router forwards the datagram received from the external interface to your internal network, to the specific IP address you defined on the forwarding rule, the network switch will broadcast that to all ports.</p><p>You&rsquo;ll find many over-architected implementations of Wake on Lan out there, even in C#. But the fact is that it&rsquo;s really simple thing.</p><h4 id=lets-see-some-c-code>Let&rsquo;s see some C# code:<a hidden class=anchor aria-hidden=true href=#lets-see-some-c-code>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net.NetworkInformation;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net.Sockets;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Text.RegularExpressions;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>namespace</span> BrunoGarcia.Net
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>sealed</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>WolManager</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>const</span> <span style=color:#8be9fd>int</span> _payloadSize = <span style=color:#bd93f9>102</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> SendMagicPacket(<span style=color:#8be9fd>string</span> mac, IPEndPoint ipEndPoint)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>var</span> macBytes = PhysicalAddress.Parse(mac).GetAddressBytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>var</span> payload = <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>byte</span>[_payloadSize];
</span></span><span style=display:flex><span>            Buffer.BlockCopy(<span style=color:#ff79c6>new</span> <span style=color:#8be9fd>byte</span>[] { <span style=color:#bd93f9>0xFF</span>, <span style=color:#bd93f9>0xFF</span>, <span style=color:#bd93f9>0xFF</span>, <span style=color:#bd93f9>0xFF</span>, <span style=color:#bd93f9>0xFF</span>, <span style=color:#bd93f9>0xFF</span> }, <span style=color:#bd93f9>0</span>, payload, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>6</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i = <span style=color:#bd93f9>1</span>; i &lt; <span style=color:#bd93f9>17</span>; i++)
</span></span><span style=display:flex><span>                Buffer.BlockCopy(macBytes, <span style=color:#bd93f9>0</span>, payload, <span style=color:#bd93f9>6</span> * i, <span style=color:#bd93f9>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>using</span> (<span style=color:#8be9fd>var</span> udp = <span style=color:#ff79c6>new</span> UdpClient())
</span></span><span style=display:flex><span>                udp.Send(payload, _payloadSize, ipEndPoint);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, it&rsquo;s a fire-and-forget operation, a single UDP datagram. The MAC address of the target machine goes in the payload. As I mentioned before, the port is not really important if you are sending the packet on the same subnet of your target computer (without the need of routing). Port on wikipedia you find to be 7 or 9. However 0 can be used:</p><p><img alt="Wake on Lan on Wireshark" loading=lazy src=/posts/2013/wake-on-lan-in-c-and-windows-8/Wake-on-Lan-on-Wireshark.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>WolManager.SendMagicPacket(<span style=color:#f1fa8c>&#34;B8-AC-6F-59-56-55&#34;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>new</span> IPEndPoint(IPAddress.Parse(<span style=color:#f1fa8c>&#34;255.255.255.255&#34;</span>), <span style=color:#bd93f9>0</span>));
</span></span></code></pre></div><p>This is fun, and I&rsquo;ve used it to power on my computer at home from the Internet a few times. But now, when I got Windows 8, the fun wasn&rsquo;t quite working.</p><p><a href=http://support.microsoft.com/kb/2776718>This KB from Microsoft</a> describes the change:</p><blockquote><p><strong>Windows 7</strong>: In Windows 7, the default shutdown operation puts the system into classic shutdown (S5) and all devices are put into the lowest power state D3. Wake-On-LAN is not officially supported from S5 in Windows 7. However, some network adapters can be left armed for wake if enough residual power is available. As a result, wake from the S5 state is possible on some systems where enough residual power was supplied to the network adapter even though the system is in S5 and devices are in D3.</p><p><strong>Windows 8</strong>: In Windows 8, the default shutdown behavior puts the system into hybrid shutdown (S4) and all devices are put into D3. Remote Wake-On-LAN from hybrid shutdown (S4) or classic shutdown (S5) is unsupported. Network adapters are explicitly not armed for Wake-On-LAN in both the classic shutdown (S5) and hybrid shutdown (S4) cases because users expect zero power consumption and battery drain in the shutdown state. This behavior removes the possibility of spurious wakes when explicit shutdown was requested. As a result, Wake-On-LAN is only supported from sleep (S3) or hibernate (S4) in Windows 8.</p></blockquote><p>What a bummer. Anyway, not time to give up, right? Digging a bit deeper one understands better the changes, and enabling wake on lan on windows 8 is possible again:</p><p>Check out <a href=http://www.pendlebury.biz/win8-wol>this post</a> from Phil Pendlebury which talks about it.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/c%23/>C#</a></li><li><a href=http://localhost:8322/tags/network/>Network</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>