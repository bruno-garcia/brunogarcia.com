<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ICMP for stealth transport of data | Bruno Garcia</title><meta name=keywords content="C#,ICMP,Network,Security"><meta name=description content="Building a covert channel over ICMP in C# using raw sockets and the NetmonAPI to tunnel data through ping packets."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="ICMP for stealth transport of data"><meta property="og:description" content="Building a covert channel over ICMP in C# using raw sockets and the NetmonAPI to tunnel data through ping packets."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-03-11T14:14:00+01:00"><meta property="article:modified_time" content="2012-03-11T14:14:00+01:00"><meta property="article:tag" content="C#"><meta property="article:tag" content="ICMP"><meta property="article:tag" content="Network"><meta property="article:tag" content="Security"><meta property="og:image" content="http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png"><meta name=twitter:title content="ICMP for stealth transport of data"><meta name=twitter:description content="Building a covert channel over ICMP in C# using raw sockets and the NetmonAPI to tunnel data through ping packets."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"ICMP for stealth transport of data","item":"http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ICMP for stealth transport of data","name":"ICMP for stealth transport of data","description":"Building a covert channel over ICMP in C# using raw sockets and the NetmonAPI to tunnel data through ping packets.","keywords":["C#","ICMP","Network","Security"],"articleBody":"ICMP (Internet Control Message Protocol) has been used for data transfer since always. Known as ICMP Tunnel, there are several projects and articles about this, mainly open source, like ICMP-Chat for unix-like that is about 10 years old now. Also an interesting article, explaining how to tunnel TCP over ICMP with a simple command line tool for unix-like environment, also ported to Windows.\nIn case you are not familiar with the idea, a description from Wikipedia follows:\n“ICMP tunneling works by injecting arbitrary data into an echo packet sent to a remote computer.”\n“This vulnerability exists because RFC 792, which is IETF’s rules governing ICMP packets, allows for an arbitrary data length for any type 0 (echo reply) or 8 (echo message) ICMP packets.”\nIt is correct to say that ICMP is normally not considered a threat, at least not by the majority of network administrators. It’s common to add security mechanisms (IDS, IPS, appliances, etc) to a corporate network, but in the end all types of ICMP packets, with all payload sizes etc, pass freely at least from within the private network to the outside world. This technique is used to send sensitive data outside a private network without relying on SMTP, HTTP or other upper layer protocol that are commonly monitored and logged.\nThe Sender The sender has very simple implementation. Considering the objective is to send data to the outside world, the reply is actually irrelevant. The Sender code does not require to handle the replies.\nAt first I started writing the Sender code with raw sockets, having lots of fun using binary operators (\u003c\u003c, \u003e\u003e, ~, etc), writing one’s complement and reading the RFC 792. Then I found the code would only run when executing as administrator. The whole idea wouldn’t make much sense if the Sender process requires elevated privilege. Take for example the ASP.NET Application Pool, as default, wouldn’t be able to run it. And the worse is that this is not something new at all, SOCK_RAW function access was blocked to non administrator users as described by this Microsoft knowledge base article since Windows NT 4.0, which means, always.\nI can still remember writing ICMP type 8 (echo request) packets with custom payload about 4 years ago, with C#, and without writing that much code anyway. So I tried the Ping class, introduced on .Net Framework 2.0 only to find a third parameter of type byte[] called buffer: Great! That’s the payload. So this is the way to go.\nA quick test with:\nnew System.Net.NetworkInformation .Ping() .Send(Dns.GetHostAddresses(\"google.com\").First(), 300, Encoding.ASCII.GetBytes(\"teste123\")); On Microsoft Network Monitor I see:\nThe Receiver Working with ICMP is not the same as standard TCP or UDP sockets. We don’t need to Bind a socket to a logical port so the operating system knows which software will handle the packets. To better describe this, I will quote a paper from SANS institute:\nAlthough ICMP messages are sent in IP packets and it uses IP as if it were a higher-level protocol, ICMP is in fact an internal part of IP, and must be implemented in every IP module.\nBecause of this behavior, monitoring processes and its TCP or UDP ports in use is pointless when using this technique.\nWhen implementing the Receiver part of this PoC, I used Microsoft Network Monitor 3.4, which has an API and already comes with a wrapper class in C# called NetmonAPI.cs. So if you want to run this code, install Microsoft Network Monitor, and add NetmonAPI.cs to your project.\nusing System; using System.Collections.Generic; using System.Linq; using System.Net; using System.Net.NetworkInformation; using System.Runtime.InteropServices; using System.Text; using Microsoft.NetworkMonitor; namespace BrunoGarcia.Net { /// /// Captures icmp packets of type Echo Request with its payload /// public unsafe sealed class IcmpPayloadCapturer : IDisposable { readonly IcmpPayloadCaptured _payloadCapturedCallback; readonly CaptureCallbackDelegate _captureHandler; readonly List\u003cuint\u003e _adapterIndex = new List\u003cuint\u003e(); readonly NmCaptureMode _captureMode; readonly int _icmpPayloadBufferSize; bool _isDisposed; uint _icmpFilterId, _icmpPayloadFieldId, _sourceIpFieldId, _icmpTypeFieldId; IntPtr _engineHandle, _frameParserHandle, _nplParserHandle, _configParserHandle; public delegate void IcmpPayloadCaptured(IPAddress sourceAddress, string payload); /// /// Monitors NICs for ICMP packets /// public IcmpPayloadCapturer(IcmpPayloadCaptured payloadCaptured, int icmpPayloadBufferSize = 2048, NmCaptureMode captureMode = NmCaptureMode.LocalOnly) { _payloadCapturedCallback = payloadCaptured; _icmpPayloadBufferSize = icmpPayloadBufferSize; _captureHandler = new CaptureCallbackDelegate(CaptureCallback); _captureMode = captureMode; } /// /// Starts capture of ICMP Echo Request payload /// public void Start(IEnumerable adapters) { if (_isDisposed) throw new ObjectDisposedException(GetType().FullName); if (NetmonAPI.NmOpenCaptureEngine(out _engineHandle) != 0) throw new Exception(@\"Failed to load Capture Engine.\"); ConfigureParser(); ConfigureAdapters(_engineHandle, adapters); } void ConfigureParser() { NetmonAPI.NmLoadNplParser(null, NmNplParserLoadingOption.NmAppendRegisteredNplSets, null, IntPtr.Zero, out _nplParserHandle); NetmonAPI.NmCreateFrameParserConfiguration(_nplParserHandle, null, IntPtr.Zero, out _configParserHandle); NetmonAPI.NmAddFilter(_configParserHandle, \"Protocol.ICMP\", out _icmpFilterId); NetmonAPI.NmAddField(_configParserHandle, \"ICMP.Type\", out _icmpTypeFieldId); NetmonAPI.NmAddField(_configParserHandle, \"IPv4.SourceAddress\", out _sourceIpFieldId); NetmonAPI.NmAddField(_configParserHandle, \"ICMP.EchoReplyRequest.ImplementationSpecificData\", out _icmpPayloadFieldId); NetmonAPI.NmCreateFrameParser(_configParserHandle, out _frameParserHandle, NmFrameParserOptimizeOption.ParserOptimizeFull); } void ConfigureAdapters(IntPtr engineHandle, IEnumerable adapters) { var adapterInfo = new NM_NIC_ADAPTER_INFO { Size = (ushort)Marshal.SizeOf(typeof(NM_NIC_ADAPTER_INFO)) }; uint adapterCount; NetmonAPI.NmGetAdapterCount(engineHandle, out adapterCount); for (uint i = 0; i \u003c adapterCount; i++) { NetmonAPI.NmGetAdapter(engineHandle, i, ref adapterInfo); if (adapters.Any(p =\u003e p.Id == string.Concat(adapterInfo.Guid.Take(38)))) { NetmonAPI.NmConfigAdapter(engineHandle, i, _captureHandler, IntPtr.Zero, NmCaptureCallbackExitMode.DiscardRemainFrames); if (NetmonAPI.NmStartCapture(engineHandle, i, _captureMode) == 0) _adapterIndex.Add(i); } } } void CaptureCallback(IntPtr captureEngine, UInt32 ladapterIndex, IntPtr callerContext, IntPtr rawFrame) { IntPtr parsedFrame, insertedRawFrame; if (NetmonAPI.NmParseFrame(_frameParserHandle, rawFrame, uint.MinValue, NmFrameParsingOption.None, out parsedFrame, out insertedRawFrame) == 0) { bool passed; NetmonAPI.NmEvaluateFilter(parsedFrame, _icmpFilterId, out passed); if (passed) ParseIcmpPacket(parsedFrame); NetmonAPI.NmCloseHandle(parsedFrame); } NetmonAPI.NmCloseHandle(rawFrame); } void ParseIcmpPacket(IntPtr parsedFrame) { ushort icmpType; NetmonAPI.NmGetFieldValueNumber16Bit(parsedFrame, _icmpTypeFieldId, out icmpType); if (icmpType == 8) // Echo Request { var bytes = new byte[_icmpPayloadBufferSize]; fixed (byte* buffer = \u0026bytes[0]) { uint size; NetmonAPI.NmGetFieldValueByteArray(parsedFrame, _icmpPayloadFieldId, (uint)_icmpPayloadBufferSize, buffer, out size); uint sourceIp; NetmonAPI.NmGetFieldValueNumber32Bit(parsedFrame, _sourceIpFieldId, out sourceIp); _payloadCapturedCallback( new IPAddress(sourceIp), Encoding.ASCII.GetString(bytes, 0, (int)size)); } } } ~IcmpPayloadCapturer() { Dispose(false); } public void Dispose() { Dispose(true); } private void Dispose(bool isDispose) { if (!_isDisposed) { _isDisposed = true; _adapterIndex.ForEach(i =\u003e NetmonAPI.NmStopCapture(_engineHandle, i)); NetmonAPI.NmCloseHandle(_engineHandle); NetmonAPI.NmCloseHandle(_frameParserHandle); NetmonAPI.NmCloseHandle(_nplParserHandle); NetmonAPI.NmCloseHandle(_configParserHandle); if (isDispose) GC.SuppressFinalize(this); } } } } Running from the console without Run as Administrator:\nObviously, running the two portions of the code on the same computer does not explain clearly what goes on behind the scenes. But note that there is nothing handling the reply from the Ping code (the Sender part). The Sender thread, is pinging Google but doesn’t know about the reply at all. The Receiver code, running on a different thread, using Microsoft Network Monitor 3.4 API is intercepting all ICMP type 8 packets and parsing its data field.\nNow adding the Sender portion to an HttpModule as I mentioned in previous post, an attacker could send sensitive data to another peer via simple ICMP echo requests. The data could be scrambled with a simple XOR or even ciphered with symmetric-key algorithm using hardcoded password or asymmetrically with a public key. Breaking large data into small chunks, would avoid fragmentation (remember MTU for Ethernet is 1500 bytes) and strangely big ICMP packets. Reordering the data on the Receiver gives great possibilities for data transfer. Even an ICMP Chat for Windows could be done, as mentioned in the introduction, exists one for unix-like systems.\nMitigation On Wikipedia mitigation section, I found:\n“Although the only way to prevent this type of tunneling is to block ICMP traffic altogether, this is not realistic for a production or real-world environment. One method for mitigation of this type of attack is to only allow fixed sized ICMP packets through firewalls to virtually eliminate this type of behavior.”\nI disagree that allowing only fixed size ICMP packets would avoid ICMP Tunnel since the data can be broken into smaller chunks, fixed ones, and reassembled by the Receiver. Using the code I created as PoC, we can easily change the size of the data, even writing fixed size data, by adding one layer to control sequence numbering, offset, etc. Also we can change the ICMP type by using instead of echo Request, Destination Unreachable, or any other. However, considering the idea here is the theft of information, sent from within the network (behind NAT for example), to an external system that will probably receive and log data not only from one, but from several compromised systems, echo Request fits perfectly.\nIt’s true that there are applications and other protocols relying on ICMP to work properly. The impact of blocking ICMP completely should be assessed prior to taking such action. Still, it should be blocked when not needed, and firewall rules to allow it on each particular case it is required.\n","wordCount":"1375","inLanguage":"en","image":"http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png","datePublished":"2012-03-11T14:14:00+01:00","dateModified":"2012-03-11T14:14:00+01:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ICMP for stealth transport of data</h1><div class=post-description>Building a covert channel over ICMP in C# using raw sockets and the NetmonAPI to tunnel data through ping packets.</div><div class=post-meta><span title='2012-03-11 14:14:00 +0100 +0100'>March 11, 2012</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Bruno Garcia</span></div></header><figure class="entry-cover cover-small"><img loading=eager srcset='http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png 320w' src=http://localhost:8322/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png sizes="(min-width: 768px) 720px, 100vw" width=320 height=174 alt></figure><div class=post-content><p>ICMP (Internet Control Message Protocol) has been used for data transfer since always. Known as <a href=http://en.wikipedia.org/wiki/ICMP_tunnel>ICMP Tunnel</a>, there are several projects and articles about this, mainly open source, like <a href=https://web.archive.org/web/20160613051415/http://freecode.com/projects/icmpchat>ICMP-Chat</a> for unix-like that is about 10 years old now. Also <a href=https://web.archive.org/web/20140714032137/http://www.sectechno.com/2010/10/31/bypassing-firewalls-using-icmp-tunnel/>an interesting article</a>, explaining how to tunnel TCP over ICMP with a simple command line tool for unix-like environment, also <a href=http://neophob.com/2007/10/pingtunnel-for-windows-icmp-tunnel/>ported to Windows</a>.</p><p>In case you are not familiar with the idea, a description from <a href=http://en.wikipedia.org/wiki/ICMP_tunnel>Wikipedia</a> follows:</p><blockquote><p><em>&ldquo;ICMP tunneling works by injecting arbitrary data into an echo packet sent to a remote computer.&rdquo;</em></p><p><em>&ldquo;This vulnerability exists because <a href=http://www.ietf.org/rfc/rfc792.txt>RFC 792</a>, which is IETF&rsquo;s rules governing ICMP packets, allows for an arbitrary data length for any type 0 (echo reply) or 8 (echo message) ICMP packets.&rdquo;</em></p></blockquote><p>It is correct to say that ICMP is normally not considered a threat, at least not by the majority of network administrators. It&rsquo;s common to add security mechanisms (IDS, IPS, appliances, etc) to a corporate network, but in the end all types of ICMP packets, with all payload sizes etc, pass freely at least from within the private network to the outside world. This technique is used to send sensitive data outside a private network without relying on SMTP, HTTP or other upper layer protocol that are commonly monitored and logged.</p><h2 id=the-sender>The Sender<a hidden class=anchor aria-hidden=true href=#the-sender>#</a></h2><p>The sender has very simple implementation. Considering the objective is to send data to the outside world, the reply is actually irrelevant. The Sender code does not require to handle the replies.</p><p>At first I started writing the Sender code with raw sockets, having lots of fun using binary operators (<code>&lt;&lt;</code>, <code>>></code>, <code>~</code>, etc), writing <a href=https://web.archive.org/web/20250604071232/http://mathforum.org/library/drmath/view/54379.html>one&rsquo;s complement</a> and reading the <a href=http://www.ietf.org/rfc/rfc792.txt>RFC 792</a>. Then I found the code would only run when executing as administrator. The whole idea wouldn&rsquo;t make much sense if the Sender process requires elevated privilege. Take for example the ASP.NET Application Pool, as default, wouldn&rsquo;t be able to run it. And the worse is that this is not something new at all, <code>SOCK_RAW</code> function access was blocked to non administrator users as described by this <a href="https://web.archive.org/web/2012/http://support.microsoft.com/default.aspx?scid=kb;en-us;Q195445">Microsoft knowledge base article</a> since Windows NT 4.0, which means, always.</p><p>I can still remember writing ICMP type 8 (echo request) packets with custom payload about 4 years ago, with C#, and without writing that much code anyway. So I tried the <code>Ping</code> class, introduced on .Net Framework 2.0 only to find a third parameter of type <code>byte[]</code> called <code>buffer</code>: Great! That&rsquo;s the payload. So this is the way to go.</p><p>A quick test with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>new</span> System.Net.NetworkInformation
</span></span><span style=display:flex><span>    .Ping()
</span></span><span style=display:flex><span>    .Send(Dns.GetHostAddresses(<span style=color:#f1fa8c>&#34;google.com&#34;</span>).First(),
</span></span><span style=display:flex><span>        <span style=color:#bd93f9>300</span>,
</span></span><span style=display:flex><span>        Encoding.ASCII.GetBytes(<span style=color:#f1fa8c>&#34;teste123&#34;</span>));
</span></span></code></pre></div><p>On Microsoft Network Monitor I see:</p><p><img alt="Custom ICMP payload" loading=lazy src=/posts/2012/icmp-for-stealth-transport-of-data/custom-icmp-payload.PNG></p><h2 id=the-receiver>The Receiver<a hidden class=anchor aria-hidden=true href=#the-receiver>#</a></h2><p>Working with ICMP is not the same as standard TCP or UDP sockets. We don&rsquo;t need to Bind a socket to a logical port so the operating system knows which software will handle the packets. To better describe this, I will quote <a href=http://www.sans.org/reading_room/whitepapers/threats/icmp-attacks-illustrated_477>a paper</a> from SANS institute:</p><blockquote><p><em>Although ICMP messages are sent in IP packets and it uses IP as if it were a higher-level protocol, ICMP is in fact an internal part of IP, and must be implemented in every IP module.</em></p></blockquote><p>Because of this behavior, monitoring processes and its TCP or UDP ports in use is pointless when using this technique.</p><p>When implementing the Receiver part of this PoC, I used <a href="https://www.microsoft.com/en-us/download/details.aspx?id=4865">Microsoft Network Monitor 3.4</a>, which has an API and already comes with a wrapper class in C# called <code>NetmonAPI.cs</code>. So if you want to run this code, install Microsoft Network Monitor, and add <code>NetmonAPI.cs</code> to your project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net.NetworkInformation;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Runtime.InteropServices;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> Microsoft.NetworkMonitor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>namespace</span> BrunoGarcia.Net
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/// Captures icmp packets of type Echo Request with its payload</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>unsafe</span> <span style=color:#8be9fd;font-style:italic>sealed</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>IcmpPayloadCapturer</span> : IDisposable
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>readonly</span> IcmpPayloadCaptured _payloadCapturedCallback;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>readonly</span> CaptureCallbackDelegate _captureHandler;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>readonly</span> List&lt;<span style=color:#8be9fd>uint</span>&gt; _adapterIndex = <span style=color:#ff79c6>new</span> List&lt;<span style=color:#8be9fd>uint</span>&gt;();
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>readonly</span> NmCaptureMode _captureMode;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>readonly</span> <span style=color:#8be9fd>int</span> _icmpPayloadBufferSize;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>bool</span> _isDisposed;
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>uint</span> _icmpFilterId, _icmpPayloadFieldId, _sourceIpFieldId, _icmpTypeFieldId;
</span></span><span style=display:flex><span>        IntPtr _engineHandle, _frameParserHandle, _nplParserHandle, _configParserHandle;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>delegate</span> <span style=color:#ff79c6>void</span> IcmpPayloadCaptured(IPAddress sourceAddress, <span style=color:#8be9fd>string</span> payload);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// Monitors NICs for ICMP packets</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> IcmpPayloadCapturer(IcmpPayloadCaptured payloadCaptured, <span style=color:#8be9fd>int</span> icmpPayloadBufferSize = <span style=color:#bd93f9>2048</span>,
</span></span><span style=display:flex><span>            NmCaptureMode captureMode = NmCaptureMode.LocalOnly)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _payloadCapturedCallback = payloadCaptured;
</span></span><span style=display:flex><span>            _icmpPayloadBufferSize = icmpPayloadBufferSize;
</span></span><span style=display:flex><span>            _captureHandler = <span style=color:#ff79c6>new</span> CaptureCallbackDelegate(CaptureCallback);
</span></span><span style=display:flex><span>            _captureMode = captureMode;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// Starts capture of ICMP Echo Request payload</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Start(IEnumerable&lt;NetworkInterface&gt; adapters)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (_isDisposed)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> ObjectDisposedException(GetType().FullName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (NetmonAPI.NmOpenCaptureEngine(<span style=color:#ff79c6>out</span> _engineHandle) != <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>throw</span> <span style=color:#ff79c6>new</span> Exception(<span style=color:#f1fa8c>@&#34;Failed to load Capture Engine.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ConfigureParser();
</span></span><span style=display:flex><span>            ConfigureAdapters(_engineHandle, adapters);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>void</span> ConfigureParser()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            NetmonAPI.NmLoadNplParser(<span style=color:#ff79c6>null</span>, NmNplParserLoadingOption.NmAppendRegisteredNplSets,
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>null</span>, IntPtr.Zero, <span style=color:#ff79c6>out</span> _nplParserHandle);
</span></span><span style=display:flex><span>            NetmonAPI.NmCreateFrameParserConfiguration(_nplParserHandle, <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>                IntPtr.Zero, <span style=color:#ff79c6>out</span> _configParserHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            NetmonAPI.NmAddFilter(_configParserHandle, <span style=color:#f1fa8c>&#34;Protocol.ICMP&#34;</span>, <span style=color:#ff79c6>out</span> _icmpFilterId);
</span></span><span style=display:flex><span>            NetmonAPI.NmAddField(_configParserHandle, <span style=color:#f1fa8c>&#34;ICMP.Type&#34;</span>, <span style=color:#ff79c6>out</span> _icmpTypeFieldId);
</span></span><span style=display:flex><span>            NetmonAPI.NmAddField(_configParserHandle, <span style=color:#f1fa8c>&#34;IPv4.SourceAddress&#34;</span>, <span style=color:#ff79c6>out</span> _sourceIpFieldId);
</span></span><span style=display:flex><span>            NetmonAPI.NmAddField(_configParserHandle, <span style=color:#f1fa8c>&#34;ICMP.EchoReplyRequest.ImplementationSpecificData&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>out</span> _icmpPayloadFieldId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            NetmonAPI.NmCreateFrameParser(_configParserHandle, <span style=color:#ff79c6>out</span> _frameParserHandle,
</span></span><span style=display:flex><span>                NmFrameParserOptimizeOption.ParserOptimizeFull);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>void</span> ConfigureAdapters(IntPtr engineHandle, IEnumerable&lt;NetworkInterface&gt; adapters)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>var</span> adapterInfo = <span style=color:#ff79c6>new</span> NM_NIC_ADAPTER_INFO
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Size = (<span style=color:#8be9fd>ushort</span>)Marshal.SizeOf(<span style=color:#ff79c6>typeof</span>(NM_NIC_ADAPTER_INFO))
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>uint</span> adapterCount;
</span></span><span style=display:flex><span>            NetmonAPI.NmGetAdapterCount(engineHandle, <span style=color:#ff79c6>out</span> adapterCount);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>uint</span> i = <span style=color:#bd93f9>0</span>; i &lt; adapterCount; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                NetmonAPI.NmGetAdapter(engineHandle, i, <span style=color:#ff79c6>ref</span> adapterInfo);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (adapters.Any(p =&gt; p.Id == <span style=color:#8be9fd>string</span>.Concat(adapterInfo.Guid.Take(<span style=color:#bd93f9>38</span>))))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    NetmonAPI.NmConfigAdapter(engineHandle, i, _captureHandler, IntPtr.Zero,
</span></span><span style=display:flex><span>                        NmCaptureCallbackExitMode.DiscardRemainFrames);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (NetmonAPI.NmStartCapture(engineHandle, i, _captureMode) == <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>                        _adapterIndex.Add(i);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>void</span> CaptureCallback(IntPtr captureEngine, UInt32 ladapterIndex,
</span></span><span style=display:flex><span>            IntPtr callerContext, IntPtr rawFrame)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            IntPtr parsedFrame, insertedRawFrame;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (NetmonAPI.NmParseFrame(_frameParserHandle, rawFrame, <span style=color:#8be9fd>uint</span>.MinValue,
</span></span><span style=display:flex><span>                NmFrameParsingOption.None, <span style=color:#ff79c6>out</span> parsedFrame, <span style=color:#ff79c6>out</span> insertedRawFrame) == <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>bool</span> passed;
</span></span><span style=display:flex><span>                NetmonAPI.NmEvaluateFilter(parsedFrame, _icmpFilterId, <span style=color:#ff79c6>out</span> passed);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (passed)
</span></span><span style=display:flex><span>                    ParseIcmpPacket(parsedFrame);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                NetmonAPI.NmCloseHandle(parsedFrame);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            NetmonAPI.NmCloseHandle(rawFrame);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>void</span> ParseIcmpPacket(IntPtr parsedFrame)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>ushort</span> icmpType;
</span></span><span style=display:flex><span>            NetmonAPI.NmGetFieldValueNumber16Bit(parsedFrame, _icmpTypeFieldId, <span style=color:#ff79c6>out</span> icmpType);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (icmpType == <span style=color:#bd93f9>8</span>) <span style=color:#6272a4>// Echo Request</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>var</span> bytes = <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>byte</span>[_icmpPayloadBufferSize];
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>fixed</span> (<span style=color:#8be9fd>byte</span>* buffer = &amp;bytes[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>uint</span> size;
</span></span><span style=display:flex><span>                    NetmonAPI.NmGetFieldValueByteArray(parsedFrame, _icmpPayloadFieldId,
</span></span><span style=display:flex><span>                        (<span style=color:#8be9fd>uint</span>)_icmpPayloadBufferSize, buffer, <span style=color:#ff79c6>out</span> size);
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd>uint</span> sourceIp;
</span></span><span style=display:flex><span>                    NetmonAPI.NmGetFieldValueNumber32Bit(parsedFrame, _sourceIpFieldId, <span style=color:#ff79c6>out</span> sourceIp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    _payloadCapturedCallback(
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>new</span> IPAddress(sourceIp),
</span></span><span style=display:flex><span>                        Encoding.ASCII.GetString(bytes, <span style=color:#bd93f9>0</span>, (<span style=color:#8be9fd>int</span>)size));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ~IcmpPayloadCapturer() { Dispose(<span style=color:#ff79c6>false</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Dispose() { Dispose(<span style=color:#ff79c6>true</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>void</span> Dispose(<span style=color:#8be9fd>bool</span> isDispose)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (!_isDisposed)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                _isDisposed = <span style=color:#ff79c6>true</span>;
</span></span><span style=display:flex><span>                _adapterIndex.ForEach(i =&gt; NetmonAPI.NmStopCapture(_engineHandle, i));
</span></span><span style=display:flex><span>                NetmonAPI.NmCloseHandle(_engineHandle);
</span></span><span style=display:flex><span>                NetmonAPI.NmCloseHandle(_frameParserHandle);
</span></span><span style=display:flex><span>                NetmonAPI.NmCloseHandle(_nplParserHandle);
</span></span><span style=display:flex><span>                NetmonAPI.NmCloseHandle(_configParserHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (isDispose)
</span></span><span style=display:flex><span>                    GC.SuppressFinalize(<span style=color:#ff79c6>this</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running from the console without <em>Run as Administrator</em>:</p><p><img alt="Sending and Reading custom ICMP payload" loading=lazy src=/posts/2012/icmp-for-stealth-transport-of-data/Sending-and-reading-custom-icmp-payload.png></p><p>Obviously, running the two portions of the code on the same computer does not explain clearly what goes on behind the scenes. But note that there is nothing handling the reply from the Ping code (the Sender part). The Sender thread, is pinging Google but doesn&rsquo;t know about the reply at all. The Receiver code, running on a different thread, using Microsoft Network Monitor 3.4 API is intercepting all ICMP type 8 packets and parsing its data field.</p><p>Now adding the Sender portion to an HttpModule as I mentioned in <a href=http://blog.brunogarcia.com/2012/02/httpmodules-now-even-easier-to-be.html>previous post</a>, an attacker could send sensitive data to another peer via simple ICMP echo requests. The data could be scrambled with a simple XOR or even ciphered with symmetric-key algorithm using hardcoded password or asymmetrically with a public key. Breaking large data into small chunks, would avoid fragmentation (remember MTU for Ethernet is 1500 bytes) and strangely big ICMP packets. Reordering the data on the Receiver gives great possibilities for data transfer. Even an ICMP Chat for Windows could be done, as mentioned in the introduction, exists one for unix-like systems.</p><h2 id=mitigation>Mitigation<a hidden class=anchor aria-hidden=true href=#mitigation>#</a></h2><p>On Wikipedia mitigation section, I found:</p><blockquote><p><em>&ldquo;Although the only way to prevent this type of tunneling is to block ICMP traffic altogether, this is not realistic for a production or real-world environment. One method for mitigation of this type of attack is to only allow fixed sized ICMP packets through firewalls to virtually eliminate this type of behavior.&rdquo;</em></p></blockquote><p>I disagree that allowing only fixed size ICMP packets would avoid ICMP Tunnel since the data can be broken into smaller chunks, fixed ones, and reassembled by the Receiver. Using the code I created as PoC, we can easily change the size of the data, even writing fixed size data, by adding one layer to control sequence numbering, offset, etc. Also we can change the ICMP type by using instead of echo Request, <a href=http://en.wikipedia.org/wiki/ICMP_Destination_Unreachable>Destination Unreachable</a>, or any other. However, considering the idea here is the theft of information, sent from within the network (behind NAT for example), to an external system that will probably receive and log data not only from one, but from several compromised systems, echo Request fits perfectly.</p><p>It&rsquo;s true that there are applications and other protocols relying on ICMP to work properly. The impact of blocking ICMP completely should be assessed prior to taking such action. Still, it should be blocked when not needed, and firewall rules to allow it on each particular case it is required.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/c%23/>C#</a></li><li><a href=http://localhost:8322/tags/icmp/>ICMP</a></li><li><a href=http://localhost:8322/tags/network/>Network</a></li><li><a href=http://localhost:8322/tags/security/>Security</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>