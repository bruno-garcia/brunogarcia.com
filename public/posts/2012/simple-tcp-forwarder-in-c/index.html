<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Simple TCP Forwarder in C# | Bruno Garcia</title><meta name=keywords content="C#,Network,Security"><meta name=description content="A lightweight TCP port forwarder written in C# — simple, async, and easy to embed in your own projects."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2012/simple-tcp-forwarder-in-c/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2012/simple-tcp-forwarder-in-c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2012/simple-tcp-forwarder-in-c/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="Simple TCP Forwarder in C#"><meta property="og:description" content="A lightweight TCP port forwarder written in C# — simple, async, and easy to embed in your own projects."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-10-09T21:43:00+02:00"><meta property="article:modified_time" content="2012-10-09T21:43:00+02:00"><meta property="article:tag" content="C#"><meta property="article:tag" content="Network"><meta property="article:tag" content="Security"><meta property="og:image" content="https://brunogarcia.com/assets/img/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunogarcia.com/assets/img/cover.jpg"><meta name=twitter:title content="Simple TCP Forwarder in C#"><meta name=twitter:description content="A lightweight TCP port forwarder written in C# — simple, async, and easy to embed in your own projects."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"Simple TCP Forwarder in C#","item":"http://localhost:8322/posts/2012/simple-tcp-forwarder-in-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Simple TCP Forwarder in C#","name":"Simple TCP Forwarder in C#","description":"A lightweight TCP port forwarder written in C# — simple, async, and easy to embed in your own projects.","keywords":["C#","Network","Security"],"articleBody":"When people ask: What would I use a TCP Forwarding tool for?\nNormally the answer goes like “to eavesdrop someone’s connection”.\nMost of our connections go over SSL (at least the most important ones) and the certificate would be invalidated in case a MITM would be on going.\nThere are some troubleshooting situations when one would use a TCP forwarding tool as a proxy from one box to another but on what basis this technique/tool is used can vary a lot.\nThere are many TCP forwarding tools available on the web. However, the truth is that no one wants to get a whole solution out of a compressed file, fire Visual Studio when accessing a computer via command line (read: reverse shell here?). On top of that, I wanted to have some fun, so I decided to write one.\nAnd how complicated is to write a TCP Forwarding tool? Or a TCP proxy if you prefer, in C#?\nIt takes only 66 lines of code using plain Socket class. And it’s fun!\nusing System; using System.Net; using System.Net.Sockets; namespace BrunoGarcia.Net { public class TcpForwarderSlim { private readonly Socket _mainSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); public void Start(IPEndPoint local, IPEndPoint remote) { _mainSocket.Bind(local); _mainSocket.Listen(10); while (true) { var source = _mainSocket.Accept(); var destination = new TcpForwarderSlim(); var state = new State(source, destination._mainSocket); destination.Connect(remote, source); source.BeginReceive(state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state); } } private void Connect(EndPoint remoteEndpoint, Socket destination) { var state = new State(_mainSocket, destination); _mainSocket.Connect(remoteEndpoint); _mainSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, SocketFlags.None, OnDataReceive, state); } private static void OnDataReceive(IAsyncResult result) { var state = (State)result.AsyncState; try { var bytesRead = state.SourceSocket.EndReceive(result); if (bytesRead \u003e 0) { state.DestinationSocket.Send(state.Buffer, bytesRead, SocketFlags.None); state.SourceSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state); } } catch { state.DestinationSocket.Close(); state.SourceSocket.Close(); } } private class State { public Socket SourceSocket { get; private set; } public Socket DestinationSocket { get; private set; } public byte[] Buffer { get; private set; } public State(Socket source, Socket destination) { SourceSocket = source; DestinationSocket = destination; Buffer = new byte[8192]; } } } } No rocket science here: using both Asynchronous (good old CLR APM in this case) and Synchronous Socket programming, few C# lines of code with one method exposed as an entry point taking the endpoints as parameter.\nWhen I say asynchronous and synchronous, it’s because the code has three synchronous methods from the Socket class been called. The first is the Socket.Accept() which blocks the thread until a connection is received. I chose this technique so that the Start method would never return and the main thread would handle the main socket.\nThe second synchronous method used is Socket.Send. This method also blocks the thread (in this case will be a thread from the ThreadPool due to async I/O that fired the receive callback). When one socket receives data, it forwards to the second socket in a synchronous manner, before asynchronously restarting to receive data.\nIn fact, a few tests I ran (where one socket is only flushing all buffer to a second socket) using BeginSend (asynchronous Socket.Send) performed slower then the synchronous Send.\nThird, the Socket.Connect() which initiates the connection with the remote endpoint, where you want the data you send to the program to be forwarded to.\nOnce a connection is established, APM is used with BeginReceive/EndReceive to receive data. This means each pair of sockets will receive data using APM and use the same thread from the pool that called the callback to send the data to the other socket.\nLet’s run it! Previously, I just wrote a class, right? That’s far from having an executable. As I mentioned before, my idea here was not to have yet another TCP Forwarding tool on Github, codeplex or codeproject, with dozens of files, so that we could forward some data.\nSo I propose a small change to the code above: Let’s add a static Main method to that class and build it as a command-line application:\nstatic void Main(string[] args) { new TcpForwarderSlim().Start( new IPEndPoint(IPAddress.Parse(args[0]), int.Parse(args[1])), new IPEndPoint(IPAddress.Parse(args[2]), int.Parse(args[3]))); } After that we can compile it with:\ncsc /o+ /debug- /out:TcpForwarder.exe /t:exe TcpForwarderSlim.cs Even though I used C# compiler version: 4.0.30319.17020, code will compile just fine even with version 2.0 of the .Net Framework. The generated assembly has size: 5,632 bytes.\nLet’s try it out by browsing xkcd. We get their IP address and setup the tunnel:\nC:\\ping xkcd.com Pinging xkcd.com [107.6.106.82] with 32 bytes of data: C:\\TcpForwarder.exe 127.0.0.1 12345 107.6.106.82 80 Great comics by the way! As usual.\nNotice the address bar contains localhost:12345, which makes sense considering we set up the tunnel as: 127.0.0.1 port 12345 as local endpoint. On the bottom of the screenshot there’s the Firefox extension DNS Flusher bar that shows ::1 which is the loopback address in IPv6.\nIf you think I might have a copy of xkcd comics number 1118 on my hard drive (the whole page, actually) and a web server binding port 12345, that’s not the case. :)\nNow, we have a class file with 73 lines of code (after adding the static Main method) but there’s still some manual job in order to get the tunnel working. So let’s try to automate this a bit more. Perhaps scripting the whole thing?!\nThe code can be a lot smaller if using minification. Got a nice hint on Stack Overflow using Visual Studio find and replace with Regex: :Wh+\nWe create a script, let’s say buildTcpForwarder.cmd, not forgetting to escape the \u003e sign with ^ so that the interpreter ignores it. Note I have the path to the C# compiler (csc.exe) on my PATH environment variable:\necho using System; using System.Net; using System.Net.Sockets; namespace BrunoGarcia.Net { public class TcpForwarderSlim { private readonly Socket MainSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); static void Main(string[] args) { new TcpForwarderSlim().Start( new IPEndPoint(IPAddress.Parse(args[0]), int.Parse(args[1])), new IPEndPoint(IPAddress.Parse(args[2]), int.Parse(args[3]))); } public void Start(IPEndPoint local, IPEndPoint remote) { MainSocket.Bind(local); MainSocket.Listen(5); while (true) { var source = MainSocket.Accept(); var destination = new TcpForwarderSlim(); var state = new State(source, destination.MainSocket); destination.Connect(remote, source); source.BeginReceive(state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state); } } private void Connect(EndPoint remoteEndpoint, Socket destination) { var state = new State(MainSocket, destination); MainSocket.Connect(remoteEndpoint); MainSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, SocketFlags.None, OnDataReceive, state); } private static void OnDataReceive(IAsyncResult result) { var state = (State)result.AsyncState; try { var bytesRead = state.SourceSocket.EndReceive(result); if (bytesRead ^\u003e 0) { state.DestinationSocket.Send(state.Buffer, bytesRead, SocketFlags.None); state.SourceSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state); } } catch { state.DestinationSocket.Close(); state.SourceSocket.Close(); } } private class State { public Socket SourceSocket { get; private set; } public Socket DestinationSocket { get; private set; } public byte[] Buffer { get; private set; } public State(Socket source, Socket destination) { SourceSocket = source; DestinationSocket = destination; Buffer = new byte[8192]; } } } } \u003e source.cs csc /o+ /debug- /out:TcpForwarder.exe /t:exe source.cs TcpForwarder.exe %1 %2 %3 %4 Now just call the script:\nC:\\buildTcpForwarder.cmd 127.0.0.1 12345 107.6.106.82 80 The source file is generated, built and the tunnel starts with the parameters we passed to the script so we can check xkcd once more via TCP Forwarding.\n","wordCount":"1164","inLanguage":"en","image":"https://brunogarcia.com/assets/img/cover.jpg","datePublished":"2012-10-09T21:43:00+02:00","dateModified":"2012-10-09T21:43:00+02:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2012/simple-tcp-forwarder-in-c/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Simple TCP Forwarder in C#</h1><div class=post-description>A lightweight TCP port forwarder written in C# — simple, async, and easy to embed in your own projects.</div><div class=post-meta><span title='2012-10-09 21:43:00 +0200 +0200'>October 9, 2012</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Bruno Garcia</span></div></header><div class=post-content><p>When people ask: What would I use a TCP Forwarding tool for?</p><p>Normally the answer goes like &ldquo;to eavesdrop someone&rsquo;s connection&rdquo;.</p><p>Most of our connections go over SSL (at least the most important ones) and the certificate would be invalidated in case a MITM would be on going.</p><p>There are some troubleshooting situations when one would use a TCP forwarding tool as a proxy from one box to another but on what basis this technique/tool is used can vary a lot.</p><p>There are many TCP forwarding tools available on the web. However, the truth is that no one wants to get a whole solution out of a compressed file, fire Visual Studio when accessing a computer via command line (read: reverse shell here?). On top of that, I wanted to have some fun, so I decided to write one.</p><p>And how complicated is to write a TCP Forwarding tool? Or a TCP proxy if you prefer, in C#?</p><p>It takes only 66 lines of code using plain Socket class. And it&rsquo;s fun!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#ff79c6>using</span> System;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net;
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> System.Net.Sockets;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>namespace</span> BrunoGarcia.Net
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TcpForwarderSlim</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>readonly</span> Socket _mainSocket = <span style=color:#ff79c6>new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#ff79c6>void</span> Start(IPEndPoint local, IPEndPoint remote)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _mainSocket.Bind(local);
</span></span><span style=display:flex><span>            _mainSocket.Listen(<span style=color:#bd93f9>10</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>var</span> source = _mainSocket.Accept();
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>var</span> destination = <span style=color:#ff79c6>new</span> TcpForwarderSlim();
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>var</span> state = <span style=color:#ff79c6>new</span> State(source, destination._mainSocket);
</span></span><span style=display:flex><span>                destination.Connect(remote, source);
</span></span><span style=display:flex><span>                source.BeginReceive(state.Buffer, <span style=color:#bd93f9>0</span>, state.Buffer.Length, <span style=color:#bd93f9>0</span>, OnDataReceive, state);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>void</span> Connect(EndPoint remoteEndpoint, Socket destination)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>var</span> state = <span style=color:#ff79c6>new</span> State(_mainSocket, destination);
</span></span><span style=display:flex><span>            _mainSocket.Connect(remoteEndpoint);
</span></span><span style=display:flex><span>            _mainSocket.BeginReceive(state.Buffer, <span style=color:#bd93f9>0</span>, state.Buffer.Length, SocketFlags.None, OnDataReceive, state);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> OnDataReceive(IAsyncResult result)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd>var</span> state = (State)result.AsyncState;
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>try</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#8be9fd>var</span> bytesRead = state.SourceSocket.EndReceive(result);
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (bytesRead &gt; <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    state.DestinationSocket.Send(state.Buffer, bytesRead, SocketFlags.None);
</span></span><span style=display:flex><span>                    state.SourceSocket.BeginReceive(state.Buffer, <span style=color:#bd93f9>0</span>, state.Buffer.Length, <span style=color:#bd93f9>0</span>, OnDataReceive, state);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>catch</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                state.DestinationSocket.Close();
</span></span><span style=display:flex><span>                state.SourceSocket.Close();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>State</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> Socket SourceSocket { <span style=color:#ff79c6>get</span>; <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> Socket DestinationSocket { <span style=color:#ff79c6>get</span>; <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd>byte</span>[] Buffer { <span style=color:#ff79c6>get</span>; <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#ff79c6>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>public</span> State(Socket source, Socket destination)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                SourceSocket = source;
</span></span><span style=display:flex><span>                DestinationSocket = destination;
</span></span><span style=display:flex><span>                Buffer = <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>byte</span>[<span style=color:#bd93f9>8192</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>No rocket science here: using both Asynchronous (good old <a href=http://msdn.microsoft.com/en-us/magazine/cc163467.aspx>CLR APM</a> in this case) and Synchronous Socket programming, few C# lines of code with one method exposed as an entry point taking the endpoints as parameter.</p><p>When I say asynchronous and synchronous, it&rsquo;s because the code has three synchronous methods from the Socket class been called. The first is the <code>Socket.Accept()</code> which blocks the thread until a connection is received. I chose this technique so that the Start method would never return and the main thread would handle the main socket.</p><p>The second synchronous method used is <code>Socket.Send</code>. This method also blocks the thread (in this case will be a thread from the ThreadPool due to async I/O that fired the receive callback). When one socket receives data, it forwards to the second socket in a synchronous manner, before asynchronously restarting to receive data.</p><p>In fact, a few tests I ran (where one socket is only flushing all buffer to a second socket) using <code>BeginSend</code> (asynchronous <code>Socket.Send</code>) performed slower then the synchronous <code>Send</code>.</p><p>Third, the <code>Socket.Connect()</code> which initiates the connection with the remote endpoint, where you want the data you send to the program to be forwarded to.</p><p>Once a connection is established, APM is used with <code>BeginReceive</code>/<code>EndReceive</code> to receive data. This means each pair of sockets will receive data using APM and use the same thread from the pool that called the callback to send the data to the other socket.</p><h2 id=lets-run-it>Let&rsquo;s run it!<a hidden class=anchor aria-hidden=true href=#lets-run-it>#</a></h2><p>Previously, I just wrote a class, right? That&rsquo;s far from having an executable.
As I mentioned before, my idea here was not to have <em>yet another TCP Forwarding</em> tool on Github, codeplex or codeproject, with dozens of files, so that we could forward some data.</p><p>So I propose a small change to the code above:
Let&rsquo;s add a <code>static Main</code> method to that class and build it as a command-line application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#ff79c6>void</span> Main(<span style=color:#8be9fd>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>new</span> TcpForwarderSlim().Start(
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>new</span> IPEndPoint(IPAddress.Parse(args[<span style=color:#bd93f9>0</span>]), <span style=color:#8be9fd>int</span>.Parse(args[<span style=color:#bd93f9>1</span>])),
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>new</span> IPEndPoint(IPAddress.Parse(args[<span style=color:#bd93f9>2</span>]), <span style=color:#8be9fd>int</span>.Parse(args[<span style=color:#bd93f9>3</span>])));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After that we can compile it with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>csc /o+ /debug- /out:TcpForwarder.exe /t:exe TcpForwarderSlim.cs
</span></span></code></pre></div><p>Even though I used C# compiler version: 4.0.30319.17020, code will compile just fine even with version 2.0 of the .Net Framework. The generated assembly has size: 5,632 bytes.</p><p>Let&rsquo;s try it out by browsing <a href=http://xkcd.com/>xkcd</a>. We get their IP address and setup the tunnel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>C:\ping xkcd.com
</span></span><span style=display:flex><span>Pinging xkcd.com [107.6.106.82] with 32 bytes of data:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>C:\TcpForwarder.exe 127.0.0.1 12345 107.6.106.82 80
</span></span></code></pre></div><p><img alt="Viewing xkcd via TCP Tunnel" loading=lazy src=/posts/2012/simple-tcp-forwarder-in-c/xkcd-via-tcp-tunnel.png></p><p>Great comics by the way! As usual.</p><p>Notice the address bar contains <code>localhost:12345</code>, which makes sense considering we set up the tunnel as: 127.0.0.1 port 12345 as local endpoint. On the bottom of the screenshot there&rsquo;s the Firefox extension <a href=https://web.archive.org/web/2023/https://addons.mozilla.org/en-us/firefox/addon/dns-flusher/>DNS Flusher</a> bar that shows <code>::1</code> which is the loopback address in IPv6.</p><p>If you think I might have a copy of xkcd comics number 1118 on my hard drive (the whole page, actually) and a web server binding port 12345, that&rsquo;s not the case. :)</p><p>Now, we have a class file with 73 lines of code (after adding the static Main method) but there&rsquo;s still some manual job in order to get the tunnel working. So let&rsquo;s try to automate this a bit more. Perhaps scripting the whole thing?!</p><p>The code can be a lot smaller if using minification. Got a nice <a href=http://stackoverflow.com/questions/1391152/c-sharp-code-minification-tools-and-techniques>hint on Stack Overflow</a> using Visual Studio find and replace with Regex: <code>:Wh+</code></p><p>We create a script, let&rsquo;s say <code>buildTcpForwarder.cmd</code>, not forgetting to escape the <code>></code> sign with <code>^</code> so that the interpreter ignores it. Note I have the path to the C# compiler (<code>csc.exe</code>) on my PATH environment variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> using System; using System.Net; using System.Net.Sockets; namespace BrunoGarcia.Net <span style=color:#ff79c6>{</span> public class TcpForwarderSlim <span style=color:#ff79c6>{</span> private <span style=color:#8be9fd;font-style:italic>readonly</span> Socket <span style=color:#8be9fd;font-style:italic>MainSocket</span> <span style=color:#ff79c6>=</span> new Socket<span style=color:#ff79c6>(</span>AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp<span style=color:#ff79c6>)</span>; static void Main<span style=color:#ff79c6>(</span>string<span style=color:#ff79c6>[]</span> args<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> new TcpForwarderSlim<span style=color:#ff79c6>()</span>.Start<span style=color:#ff79c6>(</span> new IPEndPoint<span style=color:#ff79c6>(</span>IPAddress.Parse<span style=color:#ff79c6>(</span>args<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>])</span>, int.Parse<span style=color:#ff79c6>(</span>args<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]))</span>, new IPEndPoint<span style=color:#ff79c6>(</span>IPAddress.Parse<span style=color:#ff79c6>(</span>args<span style=color:#ff79c6>[</span>2<span style=color:#ff79c6>])</span>, int.Parse<span style=color:#ff79c6>(</span>args<span style=color:#ff79c6>[</span>3<span style=color:#ff79c6>])))</span>; <span style=color:#ff79c6>}</span> public void Start<span style=color:#ff79c6>(</span>IPEndPoint local, IPEndPoint remote<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> MainSocket.Bind<span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>local</span><span style=color:#ff79c6>)</span>; MainSocket.Listen<span style=color:#ff79c6>(</span>5<span style=color:#ff79c6>)</span>; <span style=color:#ff79c6>while</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>true</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> var <span style=color:#8be9fd;font-style:italic>source</span> <span style=color:#ff79c6>=</span> MainSocket.Accept<span style=color:#ff79c6>()</span>; var <span style=color:#8be9fd;font-style:italic>destination</span> <span style=color:#ff79c6>=</span> new TcpForwarderSlim<span style=color:#ff79c6>()</span>; var <span style=color:#8be9fd;font-style:italic>state</span> <span style=color:#ff79c6>=</span> new State<span style=color:#ff79c6>(</span>source, destination.MainSocket<span style=color:#ff79c6>)</span>; destination.Connect<span style=color:#ff79c6>(</span>remote, <span style=color:#8be9fd;font-style:italic>source</span><span style=color:#ff79c6>)</span>; source.BeginReceive<span style=color:#ff79c6>(</span>state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state<span style=color:#ff79c6>)</span>; <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> private void Connect<span style=color:#ff79c6>(</span>EndPoint remoteEndpoint, Socket destination<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> var <span style=color:#8be9fd;font-style:italic>state</span> <span style=color:#ff79c6>=</span> new State<span style=color:#ff79c6>(</span>MainSocket, destination<span style=color:#ff79c6>)</span>; MainSocket.Connect<span style=color:#ff79c6>(</span>remoteEndpoint<span style=color:#ff79c6>)</span>; MainSocket.BeginReceive<span style=color:#ff79c6>(</span>state.Buffer, 0, state.Buffer.Length, SocketFlags.None, OnDataReceive, state<span style=color:#ff79c6>)</span>; <span style=color:#ff79c6>}</span> private static void OnDataReceive<span style=color:#ff79c6>(</span>IAsyncResult result<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> var <span style=color:#8be9fd;font-style:italic>state</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>State<span style=color:#ff79c6>)</span>result.AsyncState; try <span style=color:#ff79c6>{</span> var <span style=color:#8be9fd;font-style:italic>bytesRead</span> <span style=color:#ff79c6>=</span> state.SourceSocket.EndReceive<span style=color:#ff79c6>(</span>result<span style=color:#ff79c6>)</span>; <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>bytesRead ^&gt; 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> state.DestinationSocket.Send<span style=color:#ff79c6>(</span>state.Buffer, bytesRead, SocketFlags.None<span style=color:#ff79c6>)</span>; state.SourceSocket.BeginReceive<span style=color:#ff79c6>(</span>state.Buffer, 0, state.Buffer.Length, 0, OnDataReceive, state<span style=color:#ff79c6>)</span>; <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> catch <span style=color:#ff79c6>{</span> state.DestinationSocket.Close<span style=color:#ff79c6>()</span>; state.SourceSocket.Close<span style=color:#ff79c6>()</span>; <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> private class State <span style=color:#ff79c6>{</span> public Socket SourceSocket <span style=color:#ff79c6>{</span> get; private set; <span style=color:#ff79c6>}</span> public Socket DestinationSocket <span style=color:#ff79c6>{</span> get; private set; <span style=color:#ff79c6>}</span> public byte<span style=color:#ff79c6>[]</span> Buffer <span style=color:#ff79c6>{</span> get; private set; <span style=color:#ff79c6>}</span> public State<span style=color:#ff79c6>(</span>Socket source, Socket destination<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span> <span style=color:#8be9fd;font-style:italic>SourceSocket</span> <span style=color:#ff79c6>=</span> source; <span style=color:#8be9fd;font-style:italic>DestinationSocket</span> <span style=color:#ff79c6>=</span> destination; <span style=color:#8be9fd;font-style:italic>Buffer</span> <span style=color:#ff79c6>=</span> new byte<span style=color:#ff79c6>[</span>8192<span style=color:#ff79c6>]</span>; <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> <span style=color:#ff79c6>}</span> &gt; source.cs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>csc /o+ /debug- /out:TcpForwarder.exe /t:exe source.cs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TcpForwarder.exe %1 %2 %3 %4
</span></span></code></pre></div><p>Now just call the script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-fallback data-lang=fallback><span style=display:flex><span>C:\buildTcpForwarder.cmd 127.0.0.1 12345 107.6.106.82 80
</span></span></code></pre></div><p>The source file is generated, built and the tunnel starts with the parameters we passed to the script so we can check <a href=http://xkcd.com/>xkcd</a> once more via TCP Forwarding.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/c%23/>C#</a></li><li><a href=http://localhost:8322/tags/network/>Network</a></li><li><a href=http://localhost:8322/tags/security/>Security</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>