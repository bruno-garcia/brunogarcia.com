<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pitfalls on WIF+SAML2 and Selenium | Bruno Garcia</title><meta name=keywords content="C#,SAML,Selenium,Security"><meta name=description content="Common pitfalls when using Windows Identity Foundation with SAML2 tokens and automating authentication flows with Selenium."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2012/pitfalls-on-wifsaml2-and-selenium/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2012/pitfalls-on-wifsaml2-and-selenium/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2012/pitfalls-on-wifsaml2-and-selenium/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="Pitfalls on WIF+SAML2 and Selenium"><meta property="og:description" content="Common pitfalls when using Windows Identity Foundation with SAML2 tokens and automating authentication flows with Selenium."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-12-12T21:39:00+01:00"><meta property="article:modified_time" content="2012-12-12T21:39:00+01:00"><meta property="article:tag" content="C#"><meta property="article:tag" content="SAML"><meta property="article:tag" content="Selenium"><meta property="article:tag" content="Security"><meta property="og:image" content="https://brunogarcia.com/assets/img/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunogarcia.com/assets/img/cover.jpg"><meta name=twitter:title content="Pitfalls on WIF+SAML2 and Selenium"><meta name=twitter:description content="Common pitfalls when using Windows Identity Foundation with SAML2 tokens and automating authentication flows with Selenium."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"Pitfalls on WIF+SAML2 and Selenium","item":"http://localhost:8322/posts/2012/pitfalls-on-wifsaml2-and-selenium/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pitfalls on WIF+SAML2 and Selenium","name":"Pitfalls on WIF\u002bSAML2 and Selenium","description":"Common pitfalls when using Windows Identity Foundation with SAML2 tokens and automating authentication flows with Selenium.","keywords":["C#","SAML","Selenium","Security"],"articleBody":"WIF and SAML 2.0 First some background: There is a known issue on WIF (Windows Identity Foundation) for SAML 2.0 that generates cookies with a name being a GUID and the value, base64 encoded data that grows every SAMLRequest the module handles. The decoded value looks like: 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15\nIt starts with small ones but get really, really large.\nEvery client gets one of these cookies and each time they are bigger, to the point that when they are sent back to the server, an HTTP error is thrown: HTTP 400 - Bad Request (Request Header too long)\nThis msdn link has a comment with the first steps to take in case you end up with this problem. They are very straight forward and we did them even before ending up on that msdn page. Regarding their forth step (final “fix”), in our case, it was decided a different solution.\nThe solution here was to remove the cookies before they would be sent out to the user in the first place. This way, even though for some really short time the cookie existed in memory at the server, the client never got to know of its existence. To achieve that, login and logout gotta be changed. That is: SignIn and RedirectingToIdentityProvider events from the Saml2AuthenticationModule. At that point in the event pipeline, the underlying Microsoft WIF code had already added the cookies to the Response, which gives us opportunity to remove them before the headers are sent out to the client.\nWhich takes us to Selenium The final solution had to be tested before dropping new build to production. And to test it, we had to reproduce it. The issue was not known during Dev or QA phases/environments, it did not happen, so the first step was to be able to reproduce it on a controlled environment.\nBasically the idea was to use Selenium to simulate few dozens of users logging in and off in parallel until a cookie matching a GUID (plus a number?) would be received by one of the clients. There was no need to let it grow to the point of having: HTTP 400 - Bad Request (Request Header too long)\nFor that, I wrote a small application to spawn a thread for each IWebDriver (threads from the pool were conflicting the Drivers), each logging in with a different user account, removing the cookies (so user would be challenged again) and starting over.\nThe code would detect the existence of the cookie and stop the test, but to make visible (the cookies in and out) we can load Selenium driver with Firebug enabled and the cookie tab enabled and visible as default.\nThat goes like:\nconst string firebug = @\"firebug-1.10.6-fx.xpi\"; IWebDriver driver; if (includeFireBug \u0026\u0026 File.Exists(firebug)) { var profile = new FirefoxProfile(); profile.AddExtension(firebug); // Set default Firebug preferences profile.SetPreference(\"extensions.firebug.currentVersion\", \"1.10.6\"); profile.SetPreference(\"extensions.firebug.allPagesActivation\", \"on\"); profile.SetPreference(\"extensions.firebug.defaultPanelName\", \"cookies\"); profile.SetPreference(\"extensions.firebug.net.enableSites\", true); profile.SetPreference(\"extensions.firebug.cookies.enableSites\", true); driver = new FirefoxDriver(profile); } I mentioned the code would check the cookies to look for the GUID one, and with Selenium API, it’s very simple to do so:\nGuid test; if (driver.Manage().Cookies.AllCookies.Any(p =\u003e p.Name.Length \u003e= 37 \u0026\u0026 Guid.TryParse(p.Name.Substring(0, 36), out test))) { // ... } Just checked if it’s big enough to be GUID, then tried to parse the GUID part of it (note it appends some number to sequentially divide them into 2k sized each).\nTwo domains involved in this test. The service provider, let’s call: service.com and the identity provider: idp.com\nInitially I set the IWebDriver Url property to the service provider: service.com. Find the element for Login and fire a click. That would call the SAML module that would redirect the client to the identity provider: idp.com\nThe login and password input elements would be filled up and login button triggered in the IdP page. At this point, the session cookie from the IdP was sent to the browser, under idp.com domain, and client redirected back to service.com. SAML flow finished and session cookies from service.com also sent to the client.\nThat’s all we need to reproduce the issue. However, these steps had to be done over and over, several times until the issue would happen. Particularly in our case, Logout was not possible since the accounts used were test account and thus not validated, so simply deleting the cookies would enable us restart the flow (and save us some requests/time). But this means deleting cookies from both service.com and idp.com.\nUsing Selenium API, I wrote:\ndriver.Manage().Cookies.DeleteAllCookies(); Even though the method is called DeleteAllCookies, it deletes all cookies from the current domain on which the WebDriver is located. In this case, service.com, since user just landed after the SAML login. Looping the Cookies collection from within the WebDriver obviously would return only the cookies from the current domain.\nIt was the time for a second maneuver: Setting the Url property of the WebDriver to anywhere under the idp.com domain that wouldn’t return with a redirection, and call again DeleteAllCookies. That simple. I browsed the root of the domain, without any resource id, which returned 403.14 - Directory listing denied. That was enough to run a code like:\n// right after login flow finished (landed on service.com, logged in) driver.Manage().Cookies.DeleteAllCookies(); // deletes service.com cookies driver.Url = \"idp.com\"; driver.Manage().Cookies.DeleteAllCookies(); // deletes idp.com cookies After that the flow could be re-initiated. After few hundreds of times, we could reproduce the issue, add the fix, run the test again with thousands of logins, without any issues.\n","wordCount":"907","inLanguage":"en","image":"https://brunogarcia.com/assets/img/cover.jpg","datePublished":"2012-12-12T21:39:00+01:00","dateModified":"2012-12-12T21:39:00+01:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2012/pitfalls-on-wifsaml2-and-selenium/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Pitfalls on WIF+SAML2 and Selenium</h1><div class=post-description>Common pitfalls when using Windows Identity Foundation with SAML2 tokens and automating authentication flows with Selenium.</div><div class=post-meta><span title='2012-12-12 21:39:00 +0100 +0100'>December 12, 2012</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Bruno Garcia</span></div></header><div class=post-content><h2 id=wif-and-saml-20>WIF and SAML 2.0<a hidden class=anchor aria-hidden=true href=#wif-and-saml-20>#</a></h2><p>First some background: There is a <a href=http://social.msdn.microsoft.com/Forums/en-SG/Geneva/thread/ec4ea486-6a78-4b49-b66b-353144b52d0b>known issue</a> on WIF (Windows Identity Foundation) for SAML 2.0 that generates cookies with a name being a GUID and the value, base64 encoded data that grows every SAMLRequest the module handles. The decoded value looks like: <code>0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15</code></p><p>It starts with small ones but get really, really large.</p><p><img alt="WIF SAML2 GUID cookies" loading=lazy src=/posts/2012/pitfalls-on-wifsaml2-and-selenium/wif-saml2-guid-cookies.png></p><p>Every client gets one of these cookies and each time they are bigger, to the point that when they are sent back to the server, an HTTP error is thrown: <code>HTTP 400 - Bad Request (Request Header too long)</code></p><p>This <a href=http://social.msdn.microsoft.com/Forums/en-SG/Geneva/thread/ec4ea486-6a78-4b49-b66b-353144b52d0b>msdn link</a> has a comment with the first steps to take in case you end up with this problem. They are very straight forward and we did them even before ending up on that msdn page. Regarding their forth step (final &ldquo;fix&rdquo;), in our case, it was decided a different solution.</p><p>The solution here was to remove the cookies before they would be sent out to the user in the first place. This way, even though for some really short time the cookie existed in memory at the server, the client never got to know of its existence. To achieve that, login and logout gotta be changed. That is: <code>SignIn</code> and <code>RedirectingToIdentityProvider</code> events from the <code>Saml2AuthenticationModule</code>. At that point in the event pipeline, the underlying Microsoft WIF code had already added the cookies to the Response, which gives us opportunity to remove them before the headers are sent out to the client.</p><h2 id=which-takes-us-to-selenium>Which takes us to Selenium<a hidden class=anchor aria-hidden=true href=#which-takes-us-to-selenium>#</a></h2><p>The final solution had to be tested before dropping new build to production. And to test it, we had to reproduce it. The issue was not known during Dev or QA phases/environments, it did not happen, so the first step was to be able to reproduce it on a controlled environment.</p><p>Basically the idea was to use Selenium to simulate few dozens of users logging in and off in parallel until a cookie matching a GUID (plus a number?) would be received by one of the clients. There was no need to let it grow to the point of having: <code>HTTP 400 - Bad Request (Request Header too long)</code></p><p>For that, I wrote a small application to spawn a thread for each <code>IWebDriver</code> (threads from the pool were conflicting the Drivers), each logging in with a different user account, removing the cookies (so user would be challenged again) and starting over.</p><p>The code would detect the existence of the cookie and stop the test, but to make visible (the cookies in and out) we can load Selenium driver with Firebug enabled and the cookie tab enabled and visible as default.</p><p>That goes like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>const</span> <span style=color:#8be9fd>string</span> firebug = <span style=color:#f1fa8c>@&#34;firebug-1.10.6-fx.xpi&#34;</span>;
</span></span><span style=display:flex><span>IWebDriver driver;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (includeFireBug &amp;&amp; File.Exists(firebug))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>var</span> profile = <span style=color:#ff79c6>new</span> FirefoxProfile();
</span></span><span style=display:flex><span>    profile.AddExtension(firebug);
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Set default Firebug preferences</span>
</span></span><span style=display:flex><span>    profile.SetPreference(<span style=color:#f1fa8c>&#34;extensions.firebug.currentVersion&#34;</span>, <span style=color:#f1fa8c>&#34;1.10.6&#34;</span>);
</span></span><span style=display:flex><span>    profile.SetPreference(<span style=color:#f1fa8c>&#34;extensions.firebug.allPagesActivation&#34;</span>, <span style=color:#f1fa8c>&#34;on&#34;</span>);
</span></span><span style=display:flex><span>    profile.SetPreference(<span style=color:#f1fa8c>&#34;extensions.firebug.defaultPanelName&#34;</span>, <span style=color:#f1fa8c>&#34;cookies&#34;</span>);
</span></span><span style=display:flex><span>    profile.SetPreference(<span style=color:#f1fa8c>&#34;extensions.firebug.net.enableSites&#34;</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>    profile.SetPreference(<span style=color:#f1fa8c>&#34;extensions.firebug.cookies.enableSites&#34;</span>, <span style=color:#ff79c6>true</span>);
</span></span><span style=display:flex><span>    driver = <span style=color:#ff79c6>new</span> FirefoxDriver(profile);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I mentioned the code would check the cookies to look for the GUID one, and with Selenium API, it&rsquo;s very simple to do so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>Guid test;
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (driver.Manage().Cookies.AllCookies.Any(p =&gt; p.Name.Length &gt;= <span style=color:#bd93f9>37</span> 
</span></span><span style=display:flex><span>    &amp;&amp; Guid.TryParse(p.Name.Substring(<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>36</span>), <span style=color:#ff79c6>out</span> test)))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Just checked if it&rsquo;s big enough to be GUID, then tried to parse the GUID part of it (note it appends some number to sequentially divide them into 2k sized each).</p><p>Two domains involved in this test. The service provider, let&rsquo;s call: <em>service.com</em> and the identity provider: <em>idp.com</em></p><p>Initially I set the <code>IWebDriver</code> Url property to the service provider: <em>service.com</em>. Find the element for Login and fire a click. That would call the SAML module that would redirect the client to the identity provider: <em>idp.com</em></p><p>The login and password input elements would be filled up and login button triggered in the IdP page. At this point, the session cookie from the IdP was sent to the browser, under <em>idp.com</em> domain, and client redirected back to <em>service.com</em>. SAML flow finished and session cookies from <em>service.com</em> also sent to the client.</p><p>That&rsquo;s all we need to reproduce the issue. However, these steps had to be done over and over, several times until the issue would happen. Particularly in our case, Logout was not possible since the accounts used were test account and thus not validated, so simply deleting the cookies would enable us restart the flow (and save us some requests/time). But this means deleting cookies from both <em>service.com</em> and <em>idp.com</em>.</p><p>Using Selenium API, I wrote:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>driver.Manage().Cookies.DeleteAllCookies();
</span></span></code></pre></div><p>Even though the method is called <code>DeleteAllCookies</code>, it deletes <em>all</em> cookies from the <strong>current domain</strong> on which the WebDriver is located. In this case, <em>service.com</em>, since user just landed after the SAML login. Looping the Cookies collection from within the WebDriver obviously would return only the cookies from the current domain.</p><p>It was the time for a second maneuver: Setting the Url property of the WebDriver to anywhere under the <em>idp.com</em> domain that wouldn&rsquo;t return with a redirection, and call again <code>DeleteAllCookies</code>. That simple. I browsed the root of the domain, without any resource id, which returned <code>403.14 - Directory listing denied</code>. That was enough to run a code like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#6272a4>// right after login flow finished (landed on service.com, logged in)</span>
</span></span><span style=display:flex><span>driver.Manage().Cookies.DeleteAllCookies(); <span style=color:#6272a4>// deletes service.com cookies</span>
</span></span><span style=display:flex><span>driver.Url = <span style=color:#f1fa8c>&#34;idp.com&#34;</span>;
</span></span><span style=display:flex><span>driver.Manage().Cookies.DeleteAllCookies(); <span style=color:#6272a4>// deletes idp.com cookies</span>
</span></span></code></pre></div><p>After that the flow could be re-initiated. After few hundreds of times, we could reproduce the issue, add the fix, run the test again with thousands of logins, without any issues.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/c%23/>C#</a></li><li><a href=http://localhost:8322/tags/saml/>SAML</a></li><li><a href=http://localhost:8322/tags/selenium/>Selenium</a></li><li><a href=http://localhost:8322/tags/security/>Security</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>