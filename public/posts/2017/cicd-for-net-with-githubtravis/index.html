<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=8322&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet | Bruno Garcia</title><meta name=keywords content=".NET,CI/CD,GitHub,Open Source"><meta name=description content="Setting up CI/CD for .NET Core libraries with GitHub, Travis-CI, AppVeyor, Codecov, and automated NuGet publishing."><meta name=author content="Bruno Garcia"><link rel=canonical href=http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:8322/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:8322/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:8322/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:8322/apple-touch-icon.png><link rel=mask-icon href=http://localhost:8322/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link href=http://localhost:8322/css/custom.min.94d61a4faa677b041a8c9b05ce33e529d1a58a009e5c79583e31ec6b7e2cd50b.css integrity="sha256-lNYaT6pnewQajJsFzjPlKdGligCeXHlYPjHsa34s1Qs=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/10.39.0/bundle.tracing.min.js crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[Sentry.browserTracingIntegration()],tracesSampleRate:1})</script><meta property="og:url" content="http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/"><meta property="og:site_name" content="Bruno Garcia"><meta property="og:title" content="CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet"><meta property="og:description" content="Setting up CI/CD for .NET Core libraries with GitHub, Travis-CI, AppVeyor, Codecov, and automated NuGet publishing."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-02T15:14:00+01:00"><meta property="article:modified_time" content="2017-12-02T15:14:00+01:00"><meta property="article:tag" content=".NET"><meta property="article:tag" content="CI/CD"><meta property="article:tag" content="GitHub"><meta property="article:tag" content="Open Source"><meta property="og:image" content="http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/Sample-build-TravisCI.PNG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/Sample-build-TravisCI.PNG"><meta name=twitter:title content="CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet"><meta name=twitter:description content="Setting up CI/CD for .NET Core libraries with GitHub, Travis-CI, AppVeyor, Codecov, and automated NuGet publishing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:8322/posts/"},{"@type":"ListItem","position":2,"name":"CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet","item":"http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet","name":"CI\/CD for .NET with GitHub\/Travis-CI\/AppVeyor\/Codecov\/NuGet","description":"Setting up CI/CD for .NET Core libraries with GitHub, Travis-CI, AppVeyor, Codecov, and automated NuGet publishing.","keywords":[".NET","CI/CD","GitHub","Open Source"],"articleBody":"I recently setup continuous integration for a few open source projects. I used GitHub, AppVeyor, Travis-CI and Codecov. The resulting packages are deployed to NuGet.org.\nHere I aim to describe the process in an attempt to document it both for myself and hopefully help others in getting started with it.\nScenario I have some .NET Core projects on GitHub that are actually just .NET Standard libraries.\nUltimately, once they are built and tested on Windows, MacOS and Linux, I want them published to NuGet.org. I also want to use GitHub’s Release feature to document what I am pushing to NuGet.\nSome of these projects actually generate more than one NuGet package. That’s the case for Greentube.Messaging, Greentube.Serialization and Greentube.Monitoring. Depending on the change I make, I might be looking at publishing any number of those packages. I don’t want to publish all packages created while building the repository every time.\nTL;DR Travis-CI is used only to build and run tests on MacOS and Linux. AppVeyor, which runs on Windows, builds, run tests while tracking code coverage and sends the results to codecov.io. The result of AppVeyor’s build are artifacts, .nupkg files (aka: NuGet packages) ready to be sent to Nuget.org.\nIf AppVeyor is building a tag, it changes the build version to be the value of the tag. That sets the actual version of the NuGet packages created. Also, AppVeyor then creates a GitHub release in draft mode.\nAt that point from AppVeyor I can publish individual packages to NuGet with a button click. The release notes can be added to the GitHub Release and then it can be published.\nHow? Nearly all settings to AppVeyor, Travis-CI and Codecov are defined on their respective configuration files. Although it’s possible to configure all of those via their Web UI, I personally rather use the text configuration file which is version controlled.\nTravis-CI Previously I mentioned there’s no code coverage coming from the Travis-CI build. That’s because as of today there’s no way to do it. OpenCover and vstest don’t support Linux or MacOS because there’s still no released profiling API for those platforms. That seems to be going to change soon though.\nNonetheless, Travis-CI is a very nice, free for open source, CI system. Changes pushed to GitHub automatically trigger a build in both Linux and MacOS:\nUsing the Greentube.Messaging Travis-CI configuration file as an example: .travis.yml\nlanguage: csharp sudo: false mono: none os: - linux - osx osx_image: xcode8.1 dotnet: 2.0.0 dist: trusty env: global: - DOTNET_SKIP_FIRST_TIME_EXPERIENCE=true - DOTNET_CLI_TELEMETRY_OPTOUT=1 script: - ulimit -n 512; dotnet restore \u0026\u0026 ls test/**/*.csproj | grep -v 'Greentube.Messaging.Testing' | xargs -L1 dotnet test -c Release Firstly note that mono is set to none since I’m building with dotnet here. Since tests run CoreCLR, only .NET Core SDK is required. I’m building the specific projects although from the SDK version 2.0.0 forward or so it’s possible to build a solution file. That is because all I want here is to run my tests. Running dotnet test will build the dependent projects which in turn will run a dotnet restore if required. Again, this was not possible with .NET Core SDK 1.x.\nThe ulimit -n 512 is there to solve a problem when restoring NuGet packages which open too many connections. Also while trying to solve a problem, I’ve added osx_image: xcode8.1 to be able to build with .NET Core SDK 2.0.\nThere’re tons of other examples on how to get Travis-CI to build a .NET Core project.\nAppVeyor Here there’s more going on. Besides building all commits, including pull requests, AppVeyor will take code coverage and send it to codecov, create GitHub Releases and publish packages to NuGet.\nI’m going to start by describing things before spitting the configuration file in front of you:\nCode coverage I’ve tried to summarize the code coverage setup on StackOverflow before but it was never marked as an answer so here goes another try. :)\nConfiguration All project files have an extra configuration called Coverage with: DebugType=full\nThe reason for the full PDB configuration is that by default it compiles with portable pdbs and those are still not supported.\nRun Code coverage is tracked with OpenCover. I wrote a simple powershell script that will download the necessary tools and, using the .NET Core CLI, it runs all tests while tracking code coverage.\nIt has two optional arguments:\ngenerateReport — Generates an HTML report useful for testing things before sending to Codecov uploadCodecov — Sends the coverage data to Codecov.io Previously I mentioned that nearly all settings are source controlled. That is not true to the API KEY used to send code coverage results to Codecov. That value is defined as an environment variable (named CODECOV_TOKEN) on AppVeyor.\nPackaging The projects being built don’t have their version on csproj defined before committing to GitHub.\nThey are always set to 0.0.0 and that gets replaced (aka patched) by AppVeyor before building and packaging it.\nAs mentioned before, the result of AppVeyor builds, as other CI systems, are called artifacts. What is included in the artifacts list is specified via the configuration key with that same name. A glob pattern to include all nupkg is enough: **\\*.nupkg\nPackages are created with the dotnet pack command. That is true to all but 1 package: the metapackage.\nMetapackage One thing I’ve left out of the summary is the creation of a metapackage. That’s an attempt to ease into the API adoption by providing the simplest way to get started.\nNote that obviously the packages referenced by this metapackage are not included in the runtime package store. That means that using this will in fact include the dependent packages in your publish output.\nI’m publishing two metapackages, each from their own repository:\nGreentube.Serialization.All Greentube.Messaging.All Someone wants to try the API? Run a single dotnet add package command and all of the building blocks are available to them.\nI don’t expect it to be used in production though. I advise the fine grained approach instead (pay-for-play).\nCreate Running dotnet pack on a project that has no code yields no package!\nThe CLI will not build up an empty package. To create a metapackage you need to use a nuspec file.\nTo pack this one up, there’s a line in the configuration invoking nuget pack instead.\nCreating a Release I’ve added to .appveyor.yml (see below) a piece of powershell which resets the version of the build to the tag if that’s what’s being built.\nPushing a tag is the method to express the intent of creating a release.\nI’m using semver and NuGet already takes packages versioned N.N.N-something as a pre-release package.\nThat means a tag 1.0.0-beta will publish a pre-release package. On the other hand, if the tag is simply 1.0.0, that’d be a plain release.\nGitHub on the other hand doesn’t handle that automatically. AppVeyor creates the draft release on GitHub but at the bottom of the page before publishing, I still need to select that option:\nAppVeyor will push every artifact of that build to GitHub’s drafted release. Considering that I do not always publish all packages to NuGet, I remove whatever package I didn’t publish to NuGet before finalizing the GitHub release.\nIn other words:\nPush a tag to GitHub Publish desired packages to NuGet through AppVeyor UI (more below) Remove from the GitHub release the packages not deployed on the next step Publish release on GitHub (green button above) NuGet Publishing to NuGet is not done automatically as a result of the release creation mentioned above. The reason is that each build results in multiple packages as artifacts and publishing is an all or nothing approach.\nI’m looking for publishing packages in a selective way. AppVeyor has environments which can be configured to deploy specific artifacts from specific projects. Those can also be defined via the configuration file but you’d still need to define which environment (aka: package) you want to deploy anyway. At that point I’ve chosen to use AppVeyor’s UI to set-up these environments.\nThe way I’ve done it is: one AppVeyor environment for each package:\nTo get something deployed I can click a single button which pushes that single package to NuGet.org.\nDifferentiating each of those is done via regular expressions. For example the RegEx for the first item on that image is:\n/Greentube\\\\Messaging\\\\\\d.*\\\\nupkg/\nI’m still trying to push the markdown docs automatically together to NuGet. I’ve asked about it on StackOverflow a few days ago but still not answer.\nOne downside of this approach is that the dependencies between the packages have to be tracked by yourself.\nFor example:\nIf I want to publish Greentube.Messaging.DependencyInjection.Redis, I need to take into consideration that it depends on Greentube.Messaging.DependencyInjection which in turn depends on Greentube.Messaging of the same version.\nFor that reason, the 3 packages have to deployed otherwise restoring the first one will fail.\nConfiguration Again using the Greentube.Messaging as an example, here’s the .appveyor.yml\nversion: '1.0.0-alpha-{build}' init: - git config --global core.autocrlf true # If there's a tag, use that as the version. - ps: \u003e- if($env:APPVEYOR_REPO_TAG -eq \"true\"){Update-AppveyorBuild -Version \"$env:APPVEYOR_REPO_TAG_NAME\"} # Will build dependencies in release (optimize and portable pdbs) mode: build_script: - cmd: for /f %%a in ('dir /b test') do dotnet test -c Release test/%%a/%%a.csproj after_build: # packing the current Release build of all projects under src/ - cmd: for /f %%a in ('dir /b src ^| find /v \"Greentube.Messaging.All\"') do dotnet pack --no-build -c Release src/%%a/%%a.csproj # pack the metapackage which is based on nuspec - cmd: nuget pack -version %APPVEYOR_BUILD_VERSION% src\\Greentube.Messaging.All\\Greentube.Messaging.All.nuspec # Will build in Coverage mode (full pdbs) and upload coverage to Codecov on_success: - ps: .\\coverage.ps1 -UploadCodecov environment: global: DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true DOTNET_CLI_TELEMETRY_OPTOUT: 1 test: off os: Visual Studio 2017 dotnet_csproj: patch: true file: 'src\\**\\*.csproj' version: '{version}' package_version: '{version}' artifacts: - path: '**\\*.nupkg' name: messaging-nuget-packages # builds on tags will publish all nupkgs to GitHub as a Draft release deploy: release: $(appveyor_build_version) provider: GitHub auth_token: secure: DsKyNX5x7EJOCaRUpZu17qwOfpd/NWaZzmQd0aE62nBAGkqI3nASvvHfvoQTjL8y artifact: /.*\\.nupkg/ draft: true on: appveyor_repo_tag: true Note about the pace of changes Everything about .NET Core changes rapidly. The tooling around it specially. A lot of configuration I’ve come up with was added as a reaction to some issue I encountered. I’m sure many of these issues will be solved soon so configuration could be simplified. An example is the full pdbs for coverage and the profiling API on MacOS. Take that into account when getting your own setup ready.\n","wordCount":"1734","inLanguage":"en","image":"http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/Sample-build-TravisCI.PNG","datePublished":"2017-12-02T15:14:00.001+01:00","dateModified":"2017-12-02T15:14:00.001+01:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8322/posts/2017/cicd-for-net-with-githubtravis/"},"publisher":{"@type":"Person","name":"Bruno Garcia","logo":{"@type":"ImageObject","url":"http://localhost:8322/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:8322/ accesskey=h title="Bruno Garcia (Alt + H)">Bruno Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:8322/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:8322/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">CI/CD for .NET with GitHub/Travis-CI/AppVeyor/Codecov/NuGet</h1><div class=post-description>Setting up CI/CD for .NET Core libraries with GitHub, Travis-CI, AppVeyor, Codecov, and automated NuGet publishing.</div><div class=post-meta><span title='2017-12-02 15:14:00.001 +0100 +0100'>December 2, 2017</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Bruno Garcia</span></div></header><div class=post-content><p>I recently setup continuous integration for a few open source projects. I used GitHub, AppVeyor, Travis-CI and Codecov. The resulting packages are deployed to NuGet.org.</p><p>Here I aim to describe the process in an attempt to document it both for myself and hopefully help others in getting started with it.</p><h2 id=scenario>Scenario<a hidden class=anchor aria-hidden=true href=#scenario>#</a></h2><p>I have some .NET Core projects on <a href=https://github.com/bruno-garcia>GitHub</a> that are actually just .NET Standard libraries.</p><p>Ultimately, once they are built and tested on Windows, MacOS and Linux, I want them published to NuGet.org. I also want to use GitHub&rsquo;s Release feature to document what I am pushing to NuGet.</p><p>Some of these projects actually generate more than one NuGet package. That&rsquo;s the case for <a href=https://github.com/Greentube/messaging>Greentube.Messaging</a>, <a href=https://github.com/Greentube/serialization>Greentube.Serialization</a> and <a href=https://github.com/Greentube/monitoring>Greentube.Monitoring</a>. Depending on the change I make, I might be looking at publishing any number of those packages. I don&rsquo;t want to publish all packages created while building the repository every time.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>Travis-CI is used only to build and run tests on MacOS and Linux.
AppVeyor, which runs on Windows, builds, run tests while tracking code coverage and sends the results to <a href=https://codecov.io/gh/Greentube/messaging>codecov.io</a>. The result of AppVeyor&rsquo;s build are <a href=https://ci.appveyor.com/project/Greentube/messaging/build/artifacts>artifacts</a>, .nupkg files (aka: NuGet packages) ready to be sent to Nuget.org.</p><p>If AppVeyor is building a tag, it changes the build version to be the value of the tag. That sets the actual version of the NuGet packages created. Also, AppVeyor then creates a GitHub release in draft mode.</p><p>At that point from AppVeyor I can publish individual packages to NuGet with a button click.
The release notes can be added to the GitHub Release and then it can be published.</p><h2 id=how>How?<a hidden class=anchor aria-hidden=true href=#how>#</a></h2><p>Nearly all settings to AppVeyor, Travis-CI and Codecov are defined on their respective configuration files. Although it&rsquo;s possible to configure all of those via their Web UI, I personally rather use the text configuration file which is version controlled.</p><h2 id=travis-ci>Travis-CI<a hidden class=anchor aria-hidden=true href=#travis-ci>#</a></h2><p>Previously I mentioned there&rsquo;s no code coverage coming from the Travis-CI build. That&rsquo;s because as of today there&rsquo;s no way to do it. <a href=https://github.com/OpenCover/opencover/issues/601>OpenCover</a> and <a href=https://github.com/Microsoft/vstest/issues/981>vstest</a> don&rsquo;t support Linux or MacOS because there&rsquo;s still <a href=https://github.com/dotnet/coreclr/issues/445#issuecomment-338014386>no released profiling API</a> for those platforms. That seems to be going to change soon though.</p><p>Nonetheless, Travis-CI is a very nice, free for open source, CI system. Changes pushed to GitHub automatically trigger a build in both Linux and MacOS:</p><p><img alt="dotnet core build on Linux and MacOS" loading=lazy src=/posts/2017/cicd-for-net-with-githubtravis/Sample-build-TravisCI.PNG></p><p>Using the <a href=https://github.com/Greentube/messaging/blob/master/.travis.yml>Greentube.Messaging Travis-CI configuration file</a> as an example: <code>.travis.yml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>language</span>: csharp
</span></span><span style=display:flex><span><span style=color:#ff79c6>sudo</span>: <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>mono</span>: none
</span></span><span style=display:flex><span><span style=color:#ff79c6>os</span>:
</span></span><span style=display:flex><span>  - linux
</span></span><span style=display:flex><span>  - osx
</span></span><span style=display:flex><span><span style=color:#ff79c6>osx_image</span>: xcode8.1
</span></span><span style=display:flex><span><span style=color:#ff79c6>dotnet</span>: <span style=color:#bd93f9>2.0.0</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>dist</span>: trusty
</span></span><span style=display:flex><span><span style=color:#ff79c6>env</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>global</span>:
</span></span><span style=display:flex><span>    - DOTNET_SKIP_FIRST_TIME_EXPERIENCE=true
</span></span><span style=display:flex><span>    - DOTNET_CLI_TELEMETRY_OPTOUT=1
</span></span><span style=display:flex><span><span style=color:#ff79c6>script</span>:
</span></span><span style=display:flex><span> - ulimit -n 512; dotnet restore &amp;&amp; ls test/**/*.csproj | grep -v &#39;Greentube.Messaging.Testing&#39; | xargs -L1 dotnet test -c Release
</span></span></code></pre></div><p>Firstly note that <code>mono</code> is set to none since I&rsquo;m building with <code>dotnet</code> here. Since tests run CoreCLR, only .NET Core SDK is required. I&rsquo;m building the specific projects although from the SDK version 2.0.0 forward or so it&rsquo;s possible to build a solution file. That is because all I want here is to run my tests. Running <code>dotnet test</code> will build the dependent projects which in turn will run a <code>dotnet restore</code> if required. Again, this was not possible with .NET Core SDK 1.x.</p><p>The <code>ulimit -n 512</code> is there to <a href=https://github.com/NuGet/Home/issues/2163>solve a problem</a> when restoring NuGet packages which open too many connections. Also while trying to <a href=https://github.com/travis-ci/travis-ci/issues/8617>solve a problem</a>, I&rsquo;ve added <code>osx_image: xcode8.1</code> to be able to build with .NET Core SDK 2.0.</p><p>There&rsquo;re tons of other examples on how to get Travis-CI to build a .NET Core project.</p><h2 id=appveyor>AppVeyor<a hidden class=anchor aria-hidden=true href=#appveyor>#</a></h2><p>Here there&rsquo;s more going on. Besides building all commits, including pull requests, AppVeyor will take code coverage and send it to codecov, create GitHub Releases and publish packages to NuGet.</p><p>I&rsquo;m going to start by describing things before spitting the configuration file in front of you:</p><h3 id=code-coverage>Code coverage<a hidden class=anchor aria-hidden=true href=#code-coverage>#</a></h3><p>I&rsquo;ve tried to summarize the <a href=https://stackoverflow.com/questions/39950422/show-c-sharp-code-coverage-on-github-pull-requests>code coverage setup on StackOverflow</a> before but it was never marked as an answer so here goes another try. :)</p><h4 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h4><p>All project files have an extra configuration called <code>Coverage</code> with: <code>DebugType=full</code></p><p>The reason for the full PDB configuration is that by default it compiles with portable pdbs and those are still <a href=https://github.com/OpenCover/opencover/issues/610>not supported</a>.</p><h4 id=run>Run<a hidden class=anchor aria-hidden=true href=#run>#</a></h4><p>Code coverage is tracked with OpenCover. <a href=https://gist.github.com/bruno-garcia/aa06a53719aca2a2c9293fca57f8b640>I wrote a simple powershell script</a> that will download the necessary tools and, using the .NET Core CLI, it runs all tests while tracking code coverage.</p><p>It has two optional arguments:</p><ol><li><code>generateReport</code> — Generates an HTML report useful for testing things before sending to Codecov</li><li><code>uploadCodecov</code> — Sends the coverage data to <a href=https://codecov.io/gh/Greentube/messaging>Codecov.io</a></li></ol><p>Previously I mentioned that nearly all settings are source controlled. That is not true to the API KEY used to send code coverage results to Codecov. That value is defined as an environment variable (named <code>CODECOV_TOKEN</code>) on AppVeyor.</p><h3 id=packaging>Packaging<a hidden class=anchor aria-hidden=true href=#packaging>#</a></h3><p>The projects being built don&rsquo;t have their version on csproj defined before committing to GitHub.</p><p>They are always set to 0.0.0 and that gets replaced (aka patched) by AppVeyor before building and packaging it.</p><p>As mentioned before, the result of AppVeyor builds, as other CI systems, are called artifacts. What is included in the artifacts list is specified via the configuration key with that same name. A glob pattern to include all nupkg is enough: <code>**\*.nupkg</code></p><p>Packages are created with the <code>dotnet pack</code> command. That is true to all but 1 package: the metapackage.</p><h4 id=metapackage>Metapackage<a hidden class=anchor aria-hidden=true href=#metapackage>#</a></h4><p>One thing I&rsquo;ve left out of the summary is the creation of a <a href=https://docs.microsoft.com/en-us/dotnet/core/packages>metapackage</a>. That&rsquo;s an attempt to ease into the API adoption by providing the simplest way to get started.</p><p>Note that obviously the packages referenced by this metapackage are not included in the <a href=https://github.com/dotnet/docs/blob/master/docs/core/deploying/runtime-store.md>runtime package store</a>. That means that using this will in fact include the dependent packages in your publish output.</p><p>I&rsquo;m publishing two metapackages, each from their own repository:</p><ol><li><a href=https://github.com/Greentube/serialization/tree/master/src/Greentube.Serialization.All>Greentube.Serialization.All</a></li><li><a href=https://github.com/Greentube/messaging/tree/master/src/Greentube.Messaging.All>Greentube.Messaging.All</a></li></ol><p>Someone wants to try the API? Run a single <code>dotnet add package</code> command and all of the building blocks are available to them.</p><p>I don&rsquo;t expect it to be used in production though. I advise the fine grained approach instead (pay-for-play).</p><h4 id=create>Create<a hidden class=anchor aria-hidden=true href=#create>#</a></h4><p>Running <code>dotnet pack</code> on a project that has no code yields no package!</p><p>The CLI will not build up an empty package. To create a metapackage you need to use a <a href=https://github.com/Greentube/serialization/blob/master/src/Greentube.Serialization.All/Greentube.Serialization.All.nuspec>nuspec</a> file.</p><p>To pack this one up, there&rsquo;s a line in the configuration invoking <code>nuget pack</code> instead.</p><h3 id=creating-a-release>Creating a Release<a hidden class=anchor aria-hidden=true href=#creating-a-release>#</a></h3><p>I&rsquo;ve added to <code>.appveyor.yml</code> (see below) a piece of powershell which resets the version of the build to the tag if that&rsquo;s what&rsquo;s being built.</p><p>Pushing a tag is the method to express the intent of creating a release.</p><p>I&rsquo;m using <a href=https://semver.org/>semver</a> and NuGet already takes packages versioned <code>N.N.N-something</code> as a pre-release package.</p><p>That means a tag <code>1.0.0-beta</code> will publish a pre-release package. On the other hand, if the tag is simply <code>1.0.0</code>, that&rsquo;d be a plain release.</p><p>GitHub on the other hand doesn&rsquo;t handle that automatically. AppVeyor creates the draft release on GitHub but at the bottom of the page before publishing, I still need to select that option:</p><p><img alt="GitHub pre-release option" loading=lazy src=/posts/2017/cicd-for-net-with-githubtravis/GitHub-pre-release.PNG></p><p>AppVeyor will push every artifact of that build to GitHub&rsquo;s drafted release. Considering that I do not always publish all packages to NuGet, I remove whatever package I didn&rsquo;t publish to NuGet before finalizing the GitHub release.</p><p>In other words:</p><ol><li>Push a tag to GitHub</li><li>Publish desired packages to NuGet through AppVeyor UI (more below)</li><li>Remove from the GitHub release the packages not deployed on the next step</li><li>Publish release on GitHub (green button above)</li></ol><h3 id=nuget>NuGet<a hidden class=anchor aria-hidden=true href=#nuget>#</a></h3><p>Publishing to NuGet is not done automatically as a result of the release creation mentioned above. The reason is that each build results in multiple packages as artifacts and publishing is an all or nothing approach.</p><p>I&rsquo;m looking for publishing packages in a selective way. AppVeyor has <em>environments</em> which can be configured to deploy specific artifacts from specific projects. Those can also be defined via the configuration file but you&rsquo;d still need to define which environment (aka: package) you want to deploy anyway. At that point I&rsquo;ve chosen to use AppVeyor&rsquo;s UI to set-up these environments.</p><p>The way I&rsquo;ve done it is: one AppVeyor environment for each package:</p><p><img alt="AppVeyor environments" loading=lazy src=/posts/2017/cicd-for-net-with-githubtravis/AppVeyor-environments.PNG></p><p>To get something deployed I can click a single button which pushes that single package to NuGet.org.</p><p>Differentiating each of those is done via regular expressions. For example the RegEx for the first item on that image is:</p><p><code>/Greentube\\Messaging\\\d.*\\nupkg/</code></p><p>I&rsquo;m still trying to push the markdown docs automatically together to NuGet. <a href=https://stackoverflow.com/questions/47497923/push-markdown-documentation-to-nuget-org>I&rsquo;ve asked about it on StackOverflow</a> a few days ago but still not answer.</p><p>One downside of this approach is that the dependencies between the packages have to be tracked by yourself.</p><p>For example:</p><p>If I want to publish <code>Greentube.Messaging.DependencyInjection.Redis</code>, I need to take into consideration that it depends on <code>Greentube.Messaging.DependencyInjection</code> which in turn depends on <code>Greentube.Messaging</code> of the same version.</p><p>For that reason, the 3 packages have to deployed otherwise restoring the first one will fail.</p><h3 id=configuration-1>Configuration<a hidden class=anchor aria-hidden=true href=#configuration-1>#</a></h3><p>Again using the <a href=https://github.com/Greentube/messaging/blob/master/.appveyor.yml>Greentube.Messaging as an example</a>, here&rsquo;s the <code>.appveyor.yml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>version</span>: <span style=color:#f1fa8c>&#39;1.0.0-alpha-{build}&#39;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>init</span>:
</span></span><span style=display:flex><span>  - git config --global core.autocrlf true
</span></span><span style=display:flex><span>  <span style=color:#6272a4># If there&#39;s a tag, use that as the version.</span>
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>ps</span>: &gt;-<span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      if($env:APPVEYOR_REPO_TAG -eq &#34;true&#34;){Update-AppveyorBuild -Version &#34;$env:APPVEYOR_REPO_TAG_NAME&#34;}</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Will build dependencies in release (optimize and portable pdbs) mode:</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>build_script</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>cmd</span>: for /f %%a in (&#39;dir /b test&#39;) do dotnet test -c Release test/%%a/%%a.csproj
</span></span><span style=display:flex><span><span style=color:#ff79c6>after_build</span>:
</span></span><span style=display:flex><span><span style=color:#6272a4># packing the current Release build of all projects under src/</span>
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>cmd</span>: for /f %%a in (&#39;dir /b src ^| find /v &#34;Greentube.Messaging.All&#34;&#39;) do dotnet pack --no-build -c Release src/%%a/%%a.csproj
</span></span><span style=display:flex><span><span style=color:#6272a4># pack the metapackage which is based on nuspec</span>
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>cmd</span>: nuget pack -version %APPVEYOR_BUILD_VERSION% src\Greentube.Messaging.All\Greentube.Messaging.All.nuspec
</span></span><span style=display:flex><span><span style=color:#6272a4># Will build in Coverage mode (full pdbs) and upload coverage to Codecov</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>on_success</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ff79c6>ps</span>: .\coverage.ps1 -UploadCodecov
</span></span><span style=display:flex><span><span style=color:#ff79c6>environment</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>global</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>DOTNET_SKIP_FIRST_TIME_EXPERIENCE</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>DOTNET_CLI_TELEMETRY_OPTOUT</span>: <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>test</span>: <span style=color:#ff79c6>off</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>os</span>: Visual Studio 2017
</span></span><span style=display:flex><span><span style=color:#ff79c6>dotnet_csproj</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>patch</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>file</span>: <span style=color:#f1fa8c>&#39;src\**\*.csproj&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>version</span>: <span style=color:#f1fa8c>&#39;{version}&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>package_version</span>: <span style=color:#f1fa8c>&#39;{version}&#39;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>artifacts</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>path</span>: <span style=color:#f1fa8c>&#39;**\*.nupkg&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>name</span>: messaging-nuget-packages
</span></span><span style=display:flex><span><span style=color:#6272a4># builds on tags will publish all nupkgs to GitHub as a Draft release</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>deploy</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>release</span>: $(appveyor_build_version)
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>provider</span>: GitHub
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>auth_token</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>secure</span>: DsKyNX5x7EJOCaRUpZu17qwOfpd/NWaZzmQd0aE62nBAGkqI3nASvvHfvoQTjL8y
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>artifact</span>: /.*\.nupkg/
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>draft</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>on</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>appveyor_repo_tag</span>: <span style=color:#ff79c6>true</span>
</span></span></code></pre></div><h3 id=note-about-the-pace-of-changes>Note about the pace of changes<a hidden class=anchor aria-hidden=true href=#note-about-the-pace-of-changes>#</a></h3><p>Everything about .NET Core changes rapidly. The tooling around it specially. A lot of configuration I&rsquo;ve come up with was added as a reaction to some issue I encountered. I&rsquo;m sure many of these issues will be solved soon so configuration could be simplified. An example is the full pdbs for coverage and the profiling API on MacOS. Take that into account when getting your own setup ready.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:8322/tags/.net/>.NET</a></li><li><a href=http://localhost:8322/tags/ci/cd/>CI/CD</a></li><li><a href=http://localhost:8322/tags/github/>GitHub</a></li><li><a href=http://localhost:8322/tags/open-source/>Open Source</a></li></ul></footer></article></main><footer class=footer><div class=footer-projects>hobby projects:
<a href=https://codereviewtrends.com target=_blank rel=noopener>Code Review Trends</a>
·
<a href=https://nugettrends.com target=_blank rel=noopener>NuGet Trends</a></div><span>&copy; 2026 <a href=https://github.com/bruno-garcia/blog target=_blank rel=noopener>Bruno Garcia</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>